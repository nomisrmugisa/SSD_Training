import { useEffect, useRef, useState } from 'react';
import axios from 'axios';
import { saveAs } from 'file-saver';

import { Header } from '../header';
import { Table, TablePagination } from '../common/table';
import { orgUnitDetailsColumns } from '../../table/org-unit-details';
import { OrgUnitDetails } from '../../types/org-unit-details';
import { useTable } from '../../hooks/use-table';
import { useHistory } from 'react-router-dom';

import Modal from '../common/modal/modal';
import React from 'react';

import LivelihoodForm from '../training-forms/livelihood';
import WaterSanitationForm from '../training-forms/waterSanitation';
import NutritionForm from '../training-forms/nutrition';
import './org-unit-table.css';

type Props = {
    orgUnitDetails: OrgUnitDetails[];
    orgUnitId: string;

};
type ProgramStage = 'Livelihood' | 'Water Sanitation & Hygiene' | 'Nutrition' | '';

type RowInputValues = {
    reportDate?: string;
    dataValues?: Record<string, string | boolean | number>;
    events?: Record<string, string>;
    muacEventId?: string;
    // other fields if any
};

type AllRowInputValues = {
    [trackedEntityInstanceId: string]: RowInputValues;
};

interface FetchedData {
    reportDate: string;
    dueDate: string;
    eventId: string;
    events?: { [training: string]: string };
    dataValues: { [key: string]: string | boolean }; // To hold the values for each data element
    muacEventId?: string; // New field for MUAC-specific event
}


export function OrgUnitTable(props: Props) {

    const PROGRAM_STAGE_MAPPING = {
        'Livelihood': 'H0vCgsI1d4M',
        'Water Sanitation & Hygiene': 'bTVReRuHapT',
        'Nutrition': 'RXTq2YFOH5c',
        'Muac Assessment': 'HEukVrLC2dT'
    };

    const muacDataElementMapping: Record<string, string> = {
        'Oedema': 'uOJmECsPp5M',
        'Muac': 'LQNXHgUuLbD',
        'Muac Classification': 'zDIgqaXsxjg'
    };

    const dataElementIDsByFilter = {
        'Livelihood': {
            'Fisher': {
                'Fishing Oil Preparation': 'erCm8YopB1D',
                'Fishing Marketing': 'QpLUEvB2sdy',
                'Fishing Methods': 'OKc4NRIE3rS',
                'Post Handling Methods': 'SinFNAlonqG',
                'Applied Lessons': 'EvDeWfQDiuz',
                'Present': 'FY2ZuB17VW3'
            },
            'Farmer': {
                'Harvesting': 'RiNixd9BoZE',
                'Post Harvest Handling': 'oLxkWBGjWkV',
                'Land Preparation': 'Nmh0TPGuXWS',
                'Nursery Preparation': 'VyqyQ0BZISo',
                'Post Harvest Hygiene': 'EpaLpKMZj3y',
                'Losses Marking': 'aUrLyHqOf0n',
                'Weeding': 'vVKfsZ8VgiG',
                'Storage': 'YzlNvVyLIkn',
                'Applied Lessons': 'ZBAx5UMH63F',
                'Increased income': 'Tbnq2F0xX7D',
                'Increased agricultural production': 'GwKxMZ8yaBm',
                'Started a new livelihood activity': 'Ee8oyMX7Aoc',
                'Increased my skills/knowledge': 'I2KTNrvwsHT',
                'Increased my family\'s resilience to shocks': 'RW2BS4l5KcN',
                'Others': 'Si8dOtSlomM',
                'Present': 'FY2ZuB17VW3'
            }
        },
        'Nutrition': {
            'Nutrition during pregnancy and lactation': 'FVIkGrGWz1s',
            'Importance of early initiation of breastfeeding': 'URD2xr6Enhc',
            'Breastfeeding in the first 6 months': 'LzFFXJl5Iqu',
            'Exclusive breastfeeding during the first 6 months': 'ecFLn0i8QrL',
            'Dangers of mixed feeding in the first 6 months': 'tcriRRaX8Vb',
            'Breastfeeding on demand, both day and night': 'HVXgSsvtrY3',
            'Good hygiene practices': 'ijTViGLk6hP',
            'Complementary feeding': 'LzGN50sTSh3',
            'Health seeking behavior': 'C2GoFXyTUj2',
            'Growth monitoring': 'DK06Y2Viejs',
            'Kitchen gardens and fruit trees': 'NOIbysghola',
            'Cooking Demonstration': 'LhcJpqUzqcp',
            'Beneficiary Category': 'NA1ZhjvX47L',
            'Other Male': 'TQLLkvvbCD2',
            'Other Female': 'ojr5RiilqCk',
            'Present': 'FY2ZuB17VW3'
        },
        'Water Sanitation & Hygiene': {
            'Food Safety': 'Q4dJyNwdyyJ',
            'Promoters Attendance :1. CLTS': 'zwumtCV5d8h',
            'Personal Hygiene': 'POMbjIgo3EF',
            'Household Hygene': 'ss6pDJe2k6h',
            'Clean and Safe Water': 'xyaOOPDyjoN',
            'Use of Latrine and Excreta Disposal': 'dnlAV3tubDJ',
            'Present': 'FY2ZuB17VW3'
        },
        'Muac Assessment': {
            'Oedema': 'uOJmECsPp5M',
            'Muac': 'LQNXHgUuLbD',
            'Muac Classification': 'zDIgqaXsxjg'
        }
    };

    const dataElementMapping = {
        'Livelihood': {
            'Fisher': {
                'Fishing Oil Preparation': 'erCm8YopB1D',
                'Fishing Marketing': 'QpLUEvB2sdy',
                'Fishing Methods': 'vsbH6WxHVrN',
                'Post Handling Methods': 'SinFNAlonqG', // Need correct ID
                'Applied Lessons': 'ZBAx5UMH63F',       // Need correct ID
                // 'Income Earned/Week': 'td3WOxoQ4wN',
                // 'Case Stories Generated': 'sQShE9oP513'
            },
            'Farmer': {
                'Harvesting': 'RiNixd9BoZE',
                'Post Harvest Handling': 'oLxkWBGjWkV',
                'Land Preparation': 'Nmh0TPGuXWS',
                'Nursery Preparation': 'VyqyQ0BZISo',
                'Post Harvest Hygiene': 'EpaLpKMZj3y',
                'Losses Marking': 'aUrLyHqOf0n',
                'Weeding': 'vVKfsZ8VgiG',
                'Storage': 'YzlNvVyLIkn',
                'Applied Lessons': 'ZBAx5UMH63F',           // Need correct ID
                'Increased income': 'Tbnq2F0xX7D',         // Need correct ID
                'Increased agricultural production': 'GwKxMZ8yaBm', // Need correct ID
                'Started a new livelihood activity': 'Ee8oyMX7Aoc', // Need correct ID
                'Increased my skills/knowledge': 'I2KTNrvwsHT',    // Need correct ID
                'Increased my family\'s resilience to shocks': 'RW2BS4l5KcN', // Need correct ID
                'Others': 'Si8dOtSlomM'                    // Need correct ID
            }

        },
        'Nutrition': {
            'Nutrition during pregnancy and lactation': 'FVIkGrGWz1s',
            'Importance of early initiation of breastfeeding': 'URD2xr6Enhc',
            'Breastfeeding in the first 6 months': 'LzFFXJl5Iqu',
            'Exclusive breastfeeding during the first 6 months': 'ecFLn0i8QrL',
            'Dangers of mixed feeding in the first 6 months': 'tcriRRaX8Vb',
            'Breastfeeding on demand, both day and night': 'HVXgSsvtrY3',
            'Good hygiene practices': 'ijTViGLk6hP',
            'Complementary feeding': 'LzGN50sTSh3',
            'Health seeking behavior': 'C2GoFXyTUj2',
            'Growth monitoring': 'DK06Y2Viejs',
            'Kitchen gardens and fruit trees': 'NOIbysghola',
            'Cooking Demonstration': 'LhcJpqUzqcp',
            'Beneficiary Category': 'NA1ZhjvX47L',
            'Other Male': 'TQLLkvvbCD2',
            'Other Female': 'ojr5RiilqCk',
        },
        'Water Sanitation & Hygiene': {
            'Food Safety': 'Q4dJyNwdyyJ',
            'Promoters Attendance :1. CLTS': 'zwumtCV5d8h',
            'Personal Hygiene': 'POMbjIgo3EF',
            'Household Hygene': 'ss6pDJe2k6h',
            'Clean and Safe Water': 'xyaOOPDyjoN',
            'Use of Latrine and Excreta Disposal': 'dnlAV3tubDJ',
        },
    };

    const dataValueMapping = {
        // Farmer-specific mappings
        'harvesting_checkBox': 'Harvesting',
        'postHarvestHandling_checkBox': 'Post Harvest Handling',
        'landPreparation_checkBox': 'Land Preparation',
        'nurseryPreparation_checkBox': 'Nursery Preparation',
        'postHarvestHygiene_checkBox': 'Post Harvest Hygiene',
        'lossesMarking_checkBox': 'Losses Marking',
        'weeding_checkBox': 'Weeding',
        'storage_checkBox': 'Storage',
        'appliedLessons_dropdown': 'Applied Lessons',
        'increasedIncome_checkBox': 'Increased income',
        'increasedProduction_checkBox': 'Increased agricultural production',
        'newLivelihood_checkBox': 'Started a new livelihood activity',
        'increasedSkills_checkBox': 'Increased my skills/knowledge',
        'increasedResilience_checkBox': 'Increased my family\'s resilience to shocks',
        'others_text': 'Others',

        // Fisher-specific mappings (existing)
        'fishingOilPreparation_checkBox': 'Fishing Oil Preparation',
        'fishingMarketing_checkBox': 'Fishing Marketing',
        'fishingMethods_checkBox': 'Fishing Methods',
        'postHandlingMethods_checkBox': 'Post Handling Methods',

        // Other existing mappings (Nutrition, Water Sanitation)
        'foodSafety_checkBox': 'Food Safety',
        'promotersAttendance_checkBox': 'Promoters Attendance :1. CLTS',
        'personalHygiene_checkBox': 'Personal Hygiene',
        'householdHygiene_checkBox': 'Household Hygene',
        'cleanSafeWater_checkBox': 'Clean and Safe Water',
        'latrineDisposal_checkBox': 'Use of Latrine and Excreta Disposal',

        // Nutrition 
        'nutritionPregnancy_checkBox': 'Nutrition during pregnancy and lactation',
        'earlyInitiation_checkBox': 'Importance of early initiation of breastfeeding',
        'breastfeedingFirst6Months_checkBox': 'Breastfeeding in the first 6 months',
        'exclusiveBreastfeeding_checkBox': 'Exclusive breastfeeding during the first 6 months',
        'dangersOfMixedFeeding_checkBox': 'Dangers of mixed feeding in the first 6 months',
        'breastFeedingOnDemand_checkBox': 'Breastfeeding on demand, both day and night',
        'goodHygiene_checkBox': 'Good hygiene practices',
        'complementaryFeeding_checkBox': 'Complementary feeding',
        'healthSeekingBehavior_checkBox': 'Health seeking behavior',
        'growthMonitoring_checkBox': 'Growth monitoring',
        'kitchenGardens_checkBox': 'Kitchen gardens and fruit trees',
        'cookingDemonstration_checkBox': 'Cooking Demonstration',
        'Beneficiary_Category_dropDown': 'Beneficiary Category',
        'Other_Male_no_input': 'Other Male',
        'Other_Female_no_input': 'Other Female',

        'present_checkBox': 'Present',

        // Nutrition assessment - Muac

        'oedema_checkBox': 'Oedema',
        'muac_num': 'Muac',
        'muacClassification_text': 'Muac Classification'

        // Remove commented out mappings
        // 'incomeEarned': 'Income Earned/Week',
        // 'yieldKgs': 'Yield in Kgs',
        // 'caseStories': 'Case Stories Generated',
        // 'landCultivated': 'Land Cultivated in Feddans',
    };

    // list out every “original” column you currently render by header/accessor
    const originalColumnOptions = [
        // { Header: '#', accessor: 'index', visible: true },
        { Header: 'Registration Date', accessor: 'recordDate', visible: true },
        { Header: 'Is Beneficiary Adult / Child', accessor: 'beneficiaryStage', visible: true },
        { Header: 'Beneficiary Type', accessor: 'beneficiaryType', visible: true },
        // { Header: 'Patient ID', accessor: 'patientID', visible: true },
        { Header: 'First Name & Middle Name', accessor: 'first_middleName', visible: true },
        { Header: 'Surname', accessor: 'surname', visible: true },
        { Header: 'Sex', accessor: 'sex', visible: true },
        { Header: 'Age', accessor: 'age', visible: true },
        { Header: 'Date of Birth', accessor: 'dob', visible: true },
        // { Header: 'Initial Muac', accessor: 'initialMuac', visible: true },
        // { Header: 'Muac Classification', accessor: 'muacClassification', visible: true },
        // { Header: 'Beneficiary Facility Registration Number', accessor: 'ben_facility_RegNo', visible: true },
        // { Header: 'Direct Patient ID', accessor: 'directPatientID', visible: true },
        { Header: 'Beneficiary Track', accessor: 'track', visible: true },
    ];

    const [columnsVis, setColumnsVis] = useState(() => {
        // Always start with the filtered originalColumnOptions (ignore localStorage)
        return originalColumnOptions.filter(column =>
            column.accessor !== 'patientID' &&
            column.accessor !== 'initialMuac' &&
            column.accessor !== 'muacClassification' &&
            column.accessor !== 'ben_facility_RegNo' &&
            column.accessor !== 'directPatientID'
        );
    });

    // const credentials = btoa(`admin:Nomisr123$$$}`);
    const [search, setSearch] = useState('');
    const history = useHistory();
    const [formVisible, setFormVisible] = useState(false);
    const [trigger, setTrigger] = useState(0); // State to trigger useEffect
    const [isLoading, setIsLoading] = useState(false); // loader for getting code
    const [userData, setUserData] = useState({
        username: '',
        surname: '',
        firstName: '',
        id: ''
    });
    const [formData, setFormData] = useState({
        recordDate: '',
        track: '',
        inactive: '',
        beneficiaryStage: '',
        careGiver: '',
        careGiverAge: '',
        patientID: '',
        firstMiddleName: '',
        surname: '',
        dob: '',
        orgUnit: '',
        topicTrainedOn: '',
        beneficiaryName: '',
        nonBeneficiaryName: '',
        sex: '',
        age: '',
        initialMuac: '',
        muacClassification: '',
        ben_facility_RegNo: '',
        directPatientID: '',

    }); // Add initial form data
    // console.log("orgUnitDetails", props.orgUnitDetails);
    const [message, setMessage] = useState(null); // State for success or error message
    const [isError, setIsError] = useState(false); // State to track if the message is an error
    const [loading, setLoading] = useState(false); //loader for saving entry
    const [orgUnitCode, setOrgUnitcode] = useState('');

    const [newRowData, setNewRowData] = useState({
        id: '',
        trackInstanceId: '',
        recordDate: '',
        track: '',
        inactive: '',
        beneficiaryStage: '',
        careGiver: '',
        careGiverAge: '',
        patientID: '',
        first_middleName: '',
        surname: '',
        dob: '',
        orgUnit: '',
        // topicTrainedOn: '',
        beneficiaryName: '',
        nonBeneficiaryName: '',
        sex: '',
        age: '',
        initialMuac: '',
        muacClassification: '',
        ben_facility_RegNo: '',
        directPatientID: '',
        beneficiaryType: '',
        muacColor: '#ffffff'
    });

    const [dateFilter, setDateFilter] = useState(''); // State for date search
    const [trackFilter, setTrackFilter] = useState(''); // State for track search
    const [beneficiarySearch, setBeneficiarySearch] = useState(''); // State for beneficiary search
    const [searchResults, setSearchResults] = useState([]); // State for search results
    const [isModalVisible, setIsModalVisible] = useState(false); // State for modal visibility

    // New state variables for filters
    const [trainingFilter, setTrainingFilter] = useState('');
    const [editableRows, setEditableRows] = useState<{ [key: string]: boolean }>({});
    const [originalValues, setOriginalValues] = useState<{ [key: string]: OrgUnitDetails }>({});

    const [selectedRecord, setSelectedRecord] = useState(null); // State to hold the selected record
    const [showFilterForm, setShowFilterForm] = useState(false); // State to control filter form visibility

    const [additionalColumns, setAdditionalColumns] = useState([]); // State to store additional columns
    const [columns, setColumns] = useState([]);

    const [selectedBeneficiary, setSelectedBeneficiary] = useState<OrgUnitDetails | null>(null);
    const [indirectBeneficiaries, setIndirectBeneficiaries] = useState<OrgUnitDetails[]>([]);
    const [isAddingIndirect, setIsAddingIndirect] = useState(false);
    const [newIndirectData, setNewIndirectData] = useState({
        id: '',
        trackInstanceId: '',
        recordDate: '',
        track: '',
        inactive: '',
        beneficiaryStage: '',
        careGiver: '',
        careGiverAge: '',
        patientID: '',
        first_middleName: '',
        surname: '',
        dob: '',
        orgUnit: '',
        // topicTrainedOn: '',
        beneficiaryName: '',
        nonBeneficiaryName: '',
        sex: '',
        age: '',
        initialMuac: '',
        muacClassification: '',
        ben_facility_RegNo: '',
        directPatientID: '',
        beneficiaryType: '',

        muacColor: '#ffffff',
    });

    const filterDataByDate = (data, selectedDate) => {
        if (!selectedDate) return data; // If no date is selected, return all data

        return data.filter(item => {
            const registrationDate = new Date(item.recordDate).toISOString().split('T')[0]; // Convert to YYYY-MM-DD format
            return registrationDate === selectedDate;
        });
    };
    // Filtered data based on the selected date
    // const filteredData = filterDataByDate(props.orgUnitDetails, dateFilter);
    const [filteredData, setFilteredData] = useState(props.orgUnitDetails);

    // const [fetchedDates, setFetchedDates] = useState<{ [key: string]: { reportDate: string; dueDate: string;[key: string]: string } }>({});
    const [fetchedDates, setFetchedDates] = useState<{ [key: string]: FetchedData }>({});
    const [selectedProgramStage, setSelectedProgramStage] = useState<ProgramStage>('');
    const [hasValidDate, setHasValidDate] = useState<{ [key: string]: boolean }>({});
    const dropdownRef = useRef<HTMLDivElement>(null);

    const [selectedTrainings, setSelectedTrainings] = useState<string[]>([]); // e.g. ['Water Sanitation & Hygiene', 'Nutrition']
    const [isNewIndirectPresent, setIsNewIndirectPresent] = useState(false);
    // for additional colms returning data
    const renderCheckCell = (val?: boolean) => val === true ? '✓' : '✗';

    // number of original (visible) columns
    const originalCount = columnsVis.filter(c => c.visible).length;
    // number of extra data columns (including the “Action” col)
    const extraCount = additionalColumns.length;
    // total columns to span:
    const totalCols = originalCount + extraCount;

    const [showTopics, setShowTopics] = useState(false);
    const topicsRef = useRef<HTMLDivElement>(null);

    const [selectedRecordOnly, setSelectedRecordOnly] = useState(false);
    const [loadingAdditionalData, setLoadingAdditionalData] = useState(false);
    const [resetTrigger, setResetTrigger] = useState(0);
    const [isNewEntry, setIsNewEntry] = useState<{ [key: string]: boolean }>({});

    const [lockSelection, setLockSelection] = useState(false);

    // Adding new event
    const [isLoadingData, setIsLoadingData] = useState(false);
    const abortControllerRef = useRef<AbortController | null>(null);
    const [lastSavedIndirectId, setLastSavedIndirectId] = useState<string | null>(null);
    const [selectionLocked, setSelectionLocked] = useState(false);

    const newIndirectRef = useRef<string | null>(null);
    const [isJustSaved, setIsJustSaved] = useState(false);
    const [editInputValues, setEditInputValues] = useState<AllRowInputValues>({});

    // Add this state to track which record is being processed
    const [currentlyProcessingId, setCurrentlyProcessingId] = useState<string | null>(null);

    // which of the “topics” (additional columns) are visible
    const [topicsVis, setTopicsVis] = useState<Record<string, boolean>>(() =>
        additionalColumns.reduce((acc, col) => {
            acc[col.accessor] = true;  // default: all on
            return acc;
        }, {} as Record<string, boolean>)
    );

    // 3. Add the brute-force useEffect - adding indirect ben and checking present
    useEffect(() => {
        if (lastSavedIndirectId && isJustSaved) {
            // Only proceed if this is a newly saved record
            const updateSingleRecord = async () => {
                // Find the index of the newly saved indirect beneficiary
                const index = indirectBeneficiaries.findIndex(
                    ben => ben.trackInstanceId === lastSavedIndirectId
                );

                // Force UI update for just this record
                setEditInputValues(prev => ({
                    ...prev,
                    [lastSavedIndirectId]: {
                        ...prev[lastSavedIndirectId],
                        dataValues: {
                            ...prev[lastSavedIndirectId]?.dataValues,
                            'Present': true,
                        },
                    },
                }));

                // Sync with API for just this record - pass the index
                await handleIndirectPresentChange(lastSavedIndirectId, true, index);

                // Cleanup
                newIndirectRef.current = null;
                setLastSavedIndirectId(null);
                setIsJustSaved(false); // Reset the flag
            };

            updateSingleRecord();
        }
    }, [lastSavedIndirectId, isJustSaved, indirectBeneficiaries]);

    // Modify the filteredData logic to account for selectedRecordOnly
    useEffect(() => {
        if (lockSelection) return; // Skip if selection is locked

        let data = props.orgUnitDetails;

        if (selectedRecordOnly && selectedBeneficiary) {
            data = [selectedBeneficiary];
        }

        if (trackFilter) {
            data = data.filter(item => item.track === trackFilter);
        }

        setFilteredData(filterDataByDate(data, dateFilter));
    }, [props.orgUnitDetails, dateFilter, trackFilter, selectedRecordOnly, selectedBeneficiary, lockSelection]);

    // 3. Add cleanup to reset lock when component unmounts
    useEffect(() => {
        return () => {
            setLockSelection(false);
        };
    }, []);

    useEffect(() => {
        return () => {
            // Unlock selection when component unmounts
            setLockSelection(false);
        };
    }, []);

    useEffect(() => {
        if (selectionLocked) return; // Skip updates when locked

        // Normal data loading logic...
    }, [props.orgUnitDetails, selectionLocked]);

    useEffect(() => {
        const handleDocumentClick = (e) => {
            if (selectionLocked && !e.target.closest('.protected-element')) {
                e.preventDefault();
                e.stopPropagation();
            }
        };

        document.addEventListener('click', handleDocumentClick);
        return () => document.removeEventListener('click', handleDocumentClick);
    }, [selectionLocked]);

    // re-initialize additional cols arrays for Topics filter
    useEffect(() => {
        const vis: Record<string, boolean> = {};
        additionalColumns.forEach(col => {
            if (
                col.accessor === 'reportDate' ||    // Always show Date of Training
                col.training === 'Muac Assessment' ||  // Always show Muac Assessment columns
                col.accessor === 'addEditEvent'
            ) {
                vis[col.accessor] = true;
            } else {
                vis[col.accessor] = topicsVis[col.accessor] ?? false;
            }
        });
        setTopicsVis(vis);
    }, [additionalColumns]);

    // show / hide dropdown
    useEffect(() => {
        const onClick = (e: MouseEvent) => {
            if (
                showTopics &&
                dropdownRef.current &&
                !dropdownRef.current.contains(e.target as Node)
            ) {
                setShowTopics(false);
            }
        };
        document.addEventListener('mousedown', onClick);
        return () => document.removeEventListener('mousedown', onClick);
    }, [showTopics]);

    // handle date filtering
    useEffect(() => {
        setFilteredData(filterDataByDate(props.orgUnitDetails, dateFilter));
    }, [dateFilter, props.orgUnitDetails]);

    // handle track filtering
    useEffect(() => {
        if (trackFilter) {
            const filteredByTrack = props.orgUnitDetails.filter(item =>
                item.track === trackFilter
            );
            setFilteredData(filteredByTrack);
        } else {
            setFilteredData(props.orgUnitDetails);
        }
    }, [trackFilter, props.orgUnitDetails]);

    // Update additional columns when training filter changes
    useEffect(() => {
        setAdditionalColumns(getAdditionalColumns(trainingFilter));
    }, [trainingFilter]);

    // update columns when track filter changes

    // Addn and Muac columns too 
    useEffect(() => {
        if (!trainingFilter) {
            setAdditionalColumns([]);
            return;
        }

        let selectedTrainings: string[] = [];

        // Livelihood is exclusive
        if (trainingFilter === 'Livelihood') {
            selectedTrainings = ['Livelihood'];
        } else {
            selectedTrainings = trainingFilter.split(',').map(t => t.trim());
        }

        const mergedCols: any[] = [];

        // Add "Date of Training" first
        mergedCols.push({
            Header: ' Date of Training',
            accessor: 'reportDate',
            headerClassName: 'additional-header-cell date-column',
            className: 'date-column',
            minWidth: 100,
            training: 'shared'
        });

        if (selectedTrainings.length > 0) {
            mergedCols.push(
                {
                    Header: ' Oedema  ',
                    accessor: 'oedema_checkBox',
                    headerClassName: 'additional-header-cell',
                    className: 'oedema_checkBox',
                    training: 'Muac Assessment',
                    minWidth: 100,

                },
                {
                    Header: ' Muac',
                    accessor: 'muac_num',
                    headerClassName: 'additional-header-cell',
                    className: 'muac-value-cell', // New class for styling
                    training: 'Muac Assessment',
                    minWidth: 100,
                    // Add custom Cell renderer
                    // Cell: ({ row }: { row: any }) => {
                    //     const muacValue = fetchedDates[row.original.trackInstanceId]?.dataValues?.['Muac'];
                    //     return muacValue || '—'; // Display the value or dash if empty
                    // }
                }
            );
        }
        // Add all topic columns from selected filters
        // Add all topic columns from selected filters
        selectedTrainings.forEach(filter => {
            const cols = getAdditionalColumns(filter);
            // Filter out MUAC columns since we already added them
            const filteredCols = cols.filter(col =>
                col.accessor !== 'oedema_checkBox' &&
                col.accessor !== 'muac_num'
            );
            mergedCols.push(...filteredCols);
        });

        setAdditionalColumns(mergedCols);
    }, [trainingFilter, trackFilter]);

    // Save Muac entiries in indirect ben table when date is preexisting
    useEffect(() => {
        if (!indirectBeneficiaries.length) return;
        const controller = new AbortController();
        const { signal } = controller;
        const loadIndirects = async () => {
            const updates: { [key: string]: FetchedData } = {};
            for (const ben of indirectBeneficiaries) {
                // re‑use your existing helper to fetch the event + dataValues for each indirect
                updates[ben.trackInstanceId] =
                    await fetchAdditionalData(ben.trackInstanceId, trainingFilter, trackFilter, signal);
            }
            setFetchedDates(prev => ({ ...prev, ...updates }));
        };
        loadIndirects();
    }, [indirectBeneficiaries, trainingFilter, trackFilter]);

    // ensure hasValidDate is set to true if a valid reportDate exists in fetchedDates even without triggering handleReportDateSubmit
    useEffect(() => {
        if (filteredData) {
            const initialValidDates: Record<string, boolean> = {};
            filteredData.forEach(item => {
                const date = fetchedDates[item.trackInstanceId]?.reportDate;
                if (date) {
                    initialValidDates[item.trackInstanceId] = true;
                }
            });
            setHasValidDate(prev => ({ ...prev, ...initialValidDates }));
        }
    }, [filteredData, fetchedDates]);

    useEffect(() => {
        const fetchData = async () => {
            setIsLoading(true);

            try {
                // First request: Fetch the organization unit code
                const orgUnitCodeResponse = await fetch(
                    `${process.env.REACT_APP_DHIS2_BASE_URL}api/organisationUnits/${props.orgUnitId}`,
                    // `api/organisationUnits/${props.orgUnitId}`,
                    {
                        method: 'GET',
                        headers: {
                            'Content-Type': 'application/json',
                            // 'Authorization': `Basic ${credentials}`,
                        },
                    }
                );
                const orgUnitCodeData = await orgUnitCodeResponse.json();
                const orgUnitCode = orgUnitCodeData.code;
                setOrgUnitcode(orgUnitCode);

                // Wait for the orgUnitCode to be set before making the second request
                if (orgUnitCode) {
                    // Second request: Fetch the generated code using the organization unit code
                    const codeResponse = await fetch(
                        `${process.env.REACT_APP_DHIS2_BASE_URL}api/trackedEntityAttributes/oqabsHE0ZUI/generate?ORG_UNIT_CODE=${orgUnitCode}`,
                        // `api/trackedEntityAttributes/oqabsHE0ZUI/generate?ORG_UNIT_CODE=${orgUnitCode}`,
                        {
                            method: 'GET',
                            headers: {
                                'Content-Type': 'application/json',
                                // 'Authorization': `Basic ${credentials}`,
                            },
                        }
                    );
                    const codeData = await codeResponse.json();

                    // If the response contains a value, update the formData
                    if (codeData && codeData.value) {
                        setFormData((prevFormData) => ({
                            ...prevFormData,
                            code: codeData.value,
                        }));
                    }
                }
            } catch (error) {
                console.error('Error fetching data:', error);
            } finally {
                setIsLoading(false);
            }
        };

        fetchData();
    }, [trigger]);

    // EFFECT: Clear message on click outside
    useEffect(() => {
        // Handler to clear the message state
        const clearMessageOnClick = () => {
            if (message) { // Only clear if there's a message showing
                setMessage(null);
                setIsError(false);
            }
        };

        // Add the listener only when a message is displayed
        if (message) {
            document.addEventListener('mousedown', clearMessageOnClick);
        }

        // Cleanup: remove the listener when the component unmounts
        // or when the message changes (to re-evaluate if the listener is needed)
        return () => {
            document.removeEventListener('mousedown', clearMessageOnClick);
        };
    }, [message]);

    useEffect(() => {
        if (filteredData.length > 0 && trainingFilter) {
            loadAllAdditionalData();
        }
    }, [filteredData, trainingFilter, trackFilter]);
    // Reset addn cols data on choosin new ben

    // Function to determine additional columns based on the training filter
    const getAdditionalColumns = (filter: string) => {
        const columns = [];

        switch (filter) {
            case 'Livelihood':
                if (trackFilter === 'Fisher') {
                    columns.push(

                        {
                            Header: ' 1. Fishing Methods', accessor: 'fishingMethods_checkBox',
                            headerClassName: 'additional-header-cell',
                            training: 'Livelihood'
                        },
                        {
                            Header: ' 2. Post Handling and Hygiene', accessor: 'postHandlingMethods_checkBox',
                            headerClassName: 'additional-header-cell',
                            training: 'Livelihood'
                        }, // Added
                        {
                            Header: ' 3. Fishing Marketing and Record Keeping', accessor: 'fishingMarketing_checkBox',
                            headerClassName: 'additional-header-cell',
                            training: 'Livelihood'
                        },
                        {
                            Header: ' 4. Fishing Oil Preparation', accessor: 'fishingOilPreparation_checkBox',
                            headerClassName: 'additional-header-cell',
                            training: 'Livelihood'
                        },
                        {
                            Header: ' 5. Did you apply the lessons from fishery training in your life',
                            accessor: 'appliedLessons_dropdown',
                            headerClassName: 'additional-header-cell dropdown-column',
                            className: 'dropdown-column',
                            minWidth: 100,
                            training: 'Livelihood'
                        }
                        // { Header: 'Estimated Fish Catch', accessor: 'estimatedFishCatch' },
                        // { Header: 'Income Earned/Week', accessor: 'incomeEarned' },
                        // { Header: 'Case Stories Generated', accessor: 'caseStories' }
                    );
                } else if (trackFilter === 'Farmer') {
                    columns.push(

                        {
                            Header: ' 1. Land Preparation and Sowing', accessor: 'landPreparation_checkBox',
                            headerClassName: 'additional-header-cell',
                            training: 'Livelihood'
                        },
                        {
                            Header: ' 2. Nursery bed Preparation and Transplanting', accessor: 'nurseryPreparation_checkBox',
                            headerClassName: 'additional-header-cell',
                            training: 'Livelihood'
                        },
                        {
                            Header: ' 3. Weeding and Pest Control', accessor: 'weeding_checkBox',
                            headerClassName: 'additional-header-cell',
                            training: 'Livelihood'
                        },
                        {
                            Header: ' 4. Harvesting', accessor: 'harvesting_checkBox',
                            headerClassName: 'additional-header-cell',
                            training: 'Livelihood'
                        },
                        {
                            Header: ' 5. Post Harvest Handling', accessor: 'postHarvestHandling_checkBox',
                            headerClassName: 'additional-header-cell',
                            training: 'Livelihood'
                        },
                        {
                            Header: ' 6. Storage', accessor: 'storage_checkBox',
                            headerClassName: 'additional-header-cell',
                            training: 'Livelihood'
                        },
                        {
                            Header: ' 7. Post Harvest Handling and Hygiene', accessor: 'postHarvestHygiene_checkBox',
                            headerClassName: 'additional-header-cell',
                            training: 'Livelihood'
                        },
                        {
                            Header: ' 8. Losses Marking and Record Keeping', accessor: 'lossesMarking_checkBox',
                            headerClassName: 'additional-header-cell',
                            training: 'Livelihood'
                        },

                        {
                            Header: ' 9. Did you apply the lessons from the farming trainings in your life', accessor: 'appliedLessons_dropdown',
                            headerClassName: 'additional-header-cell',
                            training: 'Livelihood'
                        },
                        {
                            Header: ' 10. Increased income', accessor: 'increasedIncome_checkBox',
                            headerClassName: 'additional-header-cell',
                            training: 'Livelihood'
                        },
                        {
                            Header: ' 11. Increased agricultural production', accessor: 'increasedProduction_checkBox',
                            headerClassName: 'additional-header-cell',
                            training: 'Livelihood'
                        },
                        {
                            Header: ' 12. Started a new livelihood activity', accessor: 'newLivelihood_checkBox',
                            headerClassName: 'additional-header-cell',
                            training: 'Livelihood'
                        },
                        {
                            Header: ' 13. Increased my skills/knowledge', accessor: 'increasedSkills_checkBox',
                            headerClassName: 'additional-header-cell',
                            training: 'Livelihood'
                        },
                        {
                            Header: ' 14. Increased my family\'s resilience to shocks', accessor: 'increasedResilience_checkBox',
                            headerClassName: 'additional-header-cell',
                            training: 'Livelihood'
                        },
                        {
                            Header: ' 15. Others (specify)', accessor: 'others_text',
                            headerClassName: 'additional-header-cell text-column', // Add class
                            className: 'text-column',
                            minWidth: 100,
                            training: 'Livelihood'
                        }
                        // Comment out these columns
                        // { Header: 'Income Earned/Week', accessor: 'incomeEarned' },
                        // { Header: 'Yield in Kgs', accessor: 'yieldKgs' },
                        // { Header: 'Case Stories Generated', accessor: 'caseStories' },
                        // { Header: 'Land Cultivated in Feddans', accessor: 'landCultivated' }
                    );
                }
                break;
            case 'Water Sanitation & Hygiene':
                columns.push(

                    {
                        Header: ' 1. Food Safety', accessor: 'foodSafety_checkBox',
                        headerClassName: 'additional-header-cell',
                        training: 'Water Sanitation & Hygiene'
                    },
                    {
                        Header: ' 2. CLTS (Community Lead Total Sanitation)', accessor: 'promotersAttendance_checkBox',
                        headerClassName: 'additional-header-cell',
                        training: 'Water Sanitation & Hygiene'
                    },
                    {
                        Header: ' 3. Personal Hygiene', accessor: 'personalHygiene_checkBox',
                        headerClassName: 'additional-header-cell',
                        training: 'Water Sanitation & Hygiene'
                    },
                    {
                        Header: ' 4. Household Hygene', accessor: 'householdHygiene_checkBox',
                        headerClassName: 'additional-header-cell',
                        training: 'Water Sanitation & Hygiene'
                    },
                    {
                        Header: ' 5. Clean and Safe Water', accessor: 'cleanSafeWater_checkBox',
                        headerClassName: 'additional-header-cell',
                        training: 'Water Sanitation & Hygiene'
                    },
                    {
                        Header: ' 6. Use of Latrine and Excreta Disposal', accessor: 'latrineDisposal_checkBox',
                        headerClassName: 'additional-header-cell',
                        training: 'Water Sanitation & Hygiene'
                    },
                );
                break;
            case 'Nutrition':
                columns.push(

                    {
                        Header: ' 1. Nutrition during pregnancy and lactation', accessor: 'nutritionPregnancy_checkBox',
                        headerClassName: 'additional-header-cell',
                        training: 'Nutrition'
                    },
                    {
                        Header: ' 2. Importance of early initiation of breastfeeding', accessor: 'earlyInitiation_checkBox',
                        headerClassName: 'additional-header-cell',
                        training: 'Nutrition'
                    },
                    {
                        Header: ' 3. Breastfeeding in the first 6 months', accessor: 'breastfeedingFirst6Months_checkBox',
                        headerClassName: 'additional-header-cell',
                        training: 'Nutrition'
                    },
                    {
                        Header: ' 4. Exclusive breastfeeding during the first 6 months', accessor: 'exclusiveBreastfeeding_checkBox',
                        headerClassName: 'additional-header-cell',
                        training: 'Nutrition'
                    },
                    {
                        Header: ' 5. Dangers of mixed feeding in the first 6 monthsExclusive breastfeeding during the first 6 months', accessor: 'dangersOfMixedFeeding_checkBox',
                        headerClassName: 'additional-header-cell',
                        training: 'Nutrition'
                    },
                    {
                        Header: ' 6. Breastfeeding on demand, both day and night', accessor: 'breastFeedingOnDemand_checkBox',
                        headerClassName: 'additional-header-cell',
                        training: 'Nutrition'
                    },
                    {
                        Header: ' 7. Complementary feeding', accessor: 'complementaryFeeding_checkBox',
                        headerClassName: 'additional-header-cell',
                        training: 'Nutrition'
                    },
                    {
                        Header: ' 8. Good hygiene practices', accessor: 'goodHygiene_checkBox',
                        headerClassName: 'additional-header-cell',
                        training: 'Nutrition'
                    },
                    {
                        Header: ' 9. Growth monitoring', accessor: 'growthMonitoring_checkBox',
                        headerClassName: 'additional-header-cell',
                        training: 'Nutrition'
                    },
                    {
                        Header: ' 10. Health seeking behavior', accessor: 'healthSeekingBehavior_checkBox',
                        headerClassName: 'additional-header-cell',
                        training: 'Nutrition'
                    },

                    {
                        Header: ' 11. Kitchen gardening and fruit trees', accessor: 'kitchenGardens_checkBox',
                        headerClassName: 'additional-header-cell',
                        training: 'Nutrition'
                    },
                    {
                        Header: ' 12. Cooking Demonstration', accessor: 'cookingDemonstration_checkBox',
                        headerClassName: 'additional-header-cell',
                        training: 'Nutrition'
                    },
                    {
                        Header: ' 13. Beneficiary Category', accessor: 'Beneficiary_Category_dropDown',
                        headerClassName: 'additional-header-cell dropdown-column',
                        className: 'dropdown-column',
                        minWidth: 100,
                        training: 'Nutrition'
                    },
                    {
                        Header: ' 14. Other Male', accessor: 'Other_Male_no_input',
                        headerClassName: 'additional-header-cell text-column', // Add class
                        className: 'text-column',
                        minWidth: 100,
                        training: 'Nutrition'
                    },
                    {
                        Header: ' 15. Other Female', accessor: 'Other_Female_no_input',
                        headerClassName: 'additional-header-cell text-column', // Add class
                        className: 'text-column',
                        minWidth: 100,
                        training: 'Nutrition'
                    },
                );
                break;
            default:
                break;
        }
        return columns;
    };

    const table = useTable({
        data: props.orgUnitDetails,
        columns: columns, // Use the dynamically set columns
        globalFilter: search,
        setGlobalFilter: setSearch,
    });

    // New method to handle beneficiary name search
    const handleBeneficiarySearch1 = (event) => {
        const searchValue = event.target.value.toLowerCase();
        setBeneficiarySearch(searchValue);

        const filtered = props.orgUnitDetails.filter(item => {
            const searchFields = [
                item.recordDate?.toLowerCase(),
                item.beneficiaryStage?.toLowerCase(),
                item.patientID?.toLowerCase(),
                item.first_middleName?.toLowerCase(),
                item.surname?.toLowerCase(),
                item.sex?.toLowerCase(),
                item.initialMuac?.toString().toLowerCase(),
                item.muacClassification?.toLowerCase(),
                item.ben_facility_RegNo?.toLowerCase(),
                item.directPatientID?.toLowerCase(),
                item.track?.toLowerCase()
            ];

            return searchFields.some(field => field?.includes(searchValue));
        });

        setFilteredData(filterDataByDate(filtered, dateFilter));
    };

    const generatePatientId = async (): Promise<string> => {
        try {
            const response = await axios.get(
                `${process.env.REACT_APP_DHIS2_BASE_URL}api/trackedEntityAttributes/m35qF41KIdK/generate`,
                {
                    headers: { 'Content-Type': 'application/json' }
                }
            );
            return response.data.value;  // patient id
        } catch (error) {
            console.error('Error generating patient ID:', error);
            return ''; // or handle error appropriately
        }
    };

    const handleIndirectBeneficiaryAdd = async () => {
        // Generate a Patient ID from the system
        const newIndirectPatientId = await generatePatientId();
        setLockSelection(true);

        // Ensure that directPatientID is set from the selected beneficiary. 
        // If selectedBeneficiary is null, handle appropriately.
        const directPatientIDValue = selectedBeneficiary ? selectedBeneficiary.patientID : '';
        const directBenFacilityRegNo = selectedBeneficiary ? selectedBeneficiary.ben_facility_RegNo : '';

        // Update newIndirectData state with the auto-generated IDs
        setNewIndirectData(prev => ({
            ...prev,
            patientID: newIndirectPatientId,
            directPatientID: directPatientIDValue, // auto-populated
            ben_facility_RegNo: directBenFacilityRegNo
        }));

        // Trigger the display of your indirect beneficiary input form
        setIsAddingIndirect(true);
    };
    // Function to fetch user
    const fetchUser = async () => {
        try {
            const response = await fetch(
                `${process.env.REACT_APP_DHIS2_BASE_URL}api/me`,
                // `api/me`, //with proxy
                {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        // 'Authorization': `Basic ${credentials}`,
                    },
                });
            const data = await response.json();
            const userData = {
                username: data.username,
                surname: data.surname,
                firstName: data.firstName,
                id: data.id
            };
            setUserData(userData);

            return userData;

        } catch (error) {
            console.error('Error fetching user:', error);
            return null;
        }
    };
    // After successful POST (inside try block of handleSaveIndirect)
    const fetchUpdatedIndirects = async () => {
        const response = await fetch(
            `${process.env.REACT_APP_DHIS2_BASE_URL}api/trackedEntityInstances.json?ou=${props.orgUnitId}&filter=M9jR50uouZV:eq:${selectedBeneficiary?.patientID}&program=n2iAPy3PGx7`
        );
        const data = await response.json();

        if (data.trackedEntityInstances) {
            const mapped = data.trackedEntityInstances.map(instance => {
                const attrMap = instance.attributes.reduce((acc, attr) => {
                    acc[attr.attribute] = attr.value;
                    return acc;
                }, {});

                return {
                    trackInstanceId: instance.trackedEntityInstance,
                    recordDate: instance.enrollments?.[0]?.enrollmentDate || '',
                    track: attrMap['FwEpAEagGeK'] || '',
                    sex: attrMap['IVvy19BmIOw'] || '',
                    age: attrMap['lvpNOLmDEEG'] || '',
                    patientID: attrMap['m35qF41KIdK'] || '',
                    dob: attrMap['r0AIdmEpPN9'] || '',
                    beneficiaryStage: attrMap['KmxskLLhS0k'] || '',
                    first_middleName: attrMap['tUjM7KxKvCO'] || '',
                    surname: attrMap['xts0QtWHpnK'] || '',
                    initialMuac: attrMap['MX1mGZlngtD'] || '',
                    muacClassification: attrMap['KNLojwshHCv'] || '',
                    ben_facility_RegNo: attrMap['BDFFygBWNSH'] || '',
                    directPatientID: attrMap['M9jR50uouZV'] || '',
                    beneficiaryType: attrMap['fTfrFfUPTDC'] || ''
                };
            });

            setIndirectBeneficiaries(mapped);
        }
    };

    const handleSaveIndirect = async () => {
        setLoading(true);
        setLockSelection(true);
        const userData = await fetchUser();
        if (!userData) {
            console.error('Failed to get username.');
            setMessage('Failed to get username.');
            setIsError(true);
            setLoading(false);
            return;
        }

        try {
            // --- Payload 1: trackedEntityInstance ---
            const payload1 = {
                trackedEntityType: "b8gedH8Po5d",
                orgUnit: props.orgUnitId,
                attributes: [
                    { attribute: "FwEpAEagGeK", value: newIndirectData.track },
                    { attribute: "IVvy19BmIOw", value: newIndirectData.sex },
                    { attribute: "lvpNOLmDEEG", value: newIndirectData.age },
                    { attribute: "m35qF41KIdK", value: newIndirectData.patientID },
                    { attribute: "r0AIdmEpPN9", value: newIndirectData.dob },
                    { attribute: "KmxskLLhS0k", value: newIndirectData.beneficiaryStage },
                    { attribute: "tUjM7KxKvCO", value: newIndirectData.first_middleName },
                    { attribute: "xts0QtWHpnK", value: newIndirectData.surname },
                    { attribute: "MX1mGZlngtD", value: newIndirectData.initialMuac },
                    { attribute: "KNLojwshHCv", value: newIndirectData.muacClassification },
                    { attribute: "BDFFygBWNSH", value: newIndirectData.ben_facility_RegNo },
                    { attribute: "M9jR50uouZV", value: newIndirectData.directPatientID },  // Auto-populated
                    { attribute: "fTfrFfUPTDC", value: 'Indirect Beneficiary' }
                ]
            };
            const response1 = await fetch(`${process.env.REACT_APP_DHIS2_BASE_URL}api/trackedEntityInstances`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload1)
            });
            if (!response1.ok) throw new Error('Failed to create tracked entity instance');

            const trackedEntityInstance = (await response1.json()).response.importSummaries[0].reference;
            // Store the ID of the newly created indirect ben
            newIndirectRef.current = trackedEntityInstance;
            setLastSavedIndirectId(trackedEntityInstance);
            setIsJustSaved(true);

            // --- Payload 2: enrollment ---
            const payload2 = {
                trackedEntityInstance: trackedEntityInstance,
                program: "n2iAPy3PGx7",
                status: "ACTIVE",
                orgUnit: props.orgUnitId,
                enrollmentDate: newIndirectData.recordDate,
                // incidentDate: new Date().toISOString()
            };
            const response2 = await fetch(`${process.env.REACT_APP_DHIS2_BASE_URL}api/enrollments`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload2)
            });
            if (!response2.ok) throw new Error('Failed to create enrollment');

            const enrollmentId = (await response2.json()).response.importSummaries[0].reference;

            // --- Add a small delay here (Keep this for the 409 issue) ---
            await new Promise(resolve => setTimeout(resolve, 300));
            // --- End of delay ---

            // Assuming 'trackedEntityInstance' holds the ID of the newly created indirect beneficiary
            // This was populated from the response of the first payload (TEI creation)

            const createdTrainingEvents: Record<string, string> = {};
            let muacEventId = ''; // Initialize muacEventId here

            // Create events only if the 'Present' checkbox was checked
            if (isNewIndirectPresent) {
                // Create MUAC event first if 'Muac Assessment' is selected
                if (selectedTrainings.includes('Muac Assessment')) {
                    const muacPayload = {
                        events: [{
                            trackedEntityInstance: trackedEntityInstance,
                            program: 'n2iAPy3PGx7',
                            programStage: PROGRAM_STAGE_MAPPING['Muac Assessment'],
                            orgUnit: props.orgUnitId,
                            notes: [],
                            dataValues: [],
                            status: 'ACTIVE',
                            eventDate: newIndirectData.recordDate, // Use recordDate from newIndirectData
                            enrollment: enrollmentId, // Include enrollment ID
                        }]
                    };
                    try {
                        const muacRes = await axios.post( // Using axios.post for consistency
                            `${process.env.REACT_APP_DHIS2_BASE_URL}api/events`,
                            muacPayload
                        );
                        // Check for errors in the DHIS2 response body
                        if (muacRes.data.response.status === 'ERROR') {
                            console.error('Failed to create indirect MUAC event on save:', muacRes.data.response.description);
                            // Handle MUAC creation error if necessary
                        } else {
                            muacEventId = muacRes.data.response.importSummaries[0].reference;
                            console.log(`Indirect MUAC Event created on save with ID: ${muacEventId}`);
                        }
                    } catch (err) {
                        console.error('Error creating indirect MUAC event on save:', err);
                        // Handle MUAC creation error if necessary
                    }
                }


                // Create training events for other selected trainings (excluding MUAC)
                const otherTrainingsToSave = selectedTrainings.filter(training => training !== 'Muac Assessment');

                for (const training of otherTrainingsToSave) {
                    const programStage = PROGRAM_STAGE_MAPPING[training];
                    if (!programStage) {
                        console.warn(`No programStage mapped for training: "${training}"`);
                        continue; // Skip if no mapping exists
                    }

                    const eventPayload = {
                        events: [{
                            trackedEntityInstance: trackedEntityInstance,
                            program: 'n2iAPy3PGx7',
                            programStage: programStage,
                            orgUnit: props.orgUnitId,
                            notes: [],
                            // Data values would typically be empty when initially creating from the 'add' row
                            dataValues: [],
                            status: 'ACTIVE',
                            eventDate: newIndirectData.recordDate, // Use recordDate from newIndirectData
                            dueDate: newIndirectData.recordDate, // Assuming dueDate is also recordDate
                            enrollment: enrollmentId, // Include enrollment ID
                        }]
                    };

                    try {
                        const eventResponse = await axios.post( // Using axios.post here for consistency
                            `${process.env.REACT_APP_DHIS2_BASE_URL}api/events`,
                            eventPayload
                        );

                        // Check if the event creation was successful based on DHIS2 response status
                        if (eventResponse.data.response.status === 'ERROR') {
                            console.error(`Failed to create event for ${training}:`, eventResponse.data.response.description);
                            // Optionally handle error for individual training save
                        } else {
                            const createdEventId = eventResponse.data.response.importSummaries[0].reference;
                            createdTrainingEvents[training] = createdEventId; // Store the event ID
                            console.log(`Indirect Event created for ${training} on save with ID: ${createdEventId}`);
                        }
                    } catch (err) {
                        console.error(`Error creating indirect event for ${training} on save:`, err);
                        // Optionally handle error for individual training save
                    }
                }

            } // End of if (isNewIndirectPresent) block for event creation

            // --- Prepare initial dataValues based on selected trainings and MUAC ---
            // This happens regardless of whether events were created, to structure the fetchedDates state
            const initialDataValues: { [key: string]: string | boolean } = {};

            // Include data elements for MUAC if 'Muac Assessment' is selected (regardless of successful event creation)
            if (selectedTrainings.includes('Muac Assessment')) {
                Object.keys(muacDataElementMapping).forEach(label => {
                    initialDataValues[label] = ''; // Initialize MUAC data values as empty strings
                });
            }

            // Include data elements for each selected training (regardless of successful event creation)
            const allSelectedTrainings = selectedTrainings.filter(training => training !== 'Muac Assessment');
            allSelectedTrainings.forEach(trainingName => {
                const trainingSpecificMapping = dataElementMapping[trainingName];
                if (trainingSpecificMapping) {
                    // Get labels based on trackFilter if applicable, otherwise general mapping
                    // Need to correctly identify the trackFilter for the new beneficiary
                    const currentTrackFilter = newIndirectData.track; // Assuming 'track' holds the track value in newIndirectData

                    const labelsToInitialize = (currentTrackFilter && trainingSpecificMapping[currentTrackFilter])
                        ? Object.keys(trainingSpecificMapping[currentTrackFilter])
                        : Object.keys(trainingSpecificMapping);

                    labelsToInitialize.forEach(label => {
                        // Avoid overwriting existing keys if they happen to have the same label (e.g., between trainings or with MUAC)
                        if (initialDataValues[label] === undefined) {
                            // Initialize based on expected type if possible (e.g., false for checkboxes)
                            // This is tricky without data element type info. Empty string or false might work depending on rendering logic.
                            // Let's assume empty string is a safe default for most inputs. Checkboxes might need false.
                            // If your rendering handles empty string for checkboxes correctly, use ''.
                            initialDataValues[label] = ''; // Initialize training data values as empty strings
                        }
                    });
                }
            });
            // --- End Prepare initial dataValues ---

            setEditInputValues(prev => ({
                ...prev,
                [trackedEntityInstance]: {
                    reportDate: newIndirectData.recordDate || '',
                    dueDate: newIndirectData.recordDate || '',
                    eventId: isNewIndirectPresent ? (Object.values(createdTrainingEvents)[0] || muacEventId || '') : '',
                    muacEventId: isNewIndirectPresent ? muacEventId : '',
                    events: isNewIndirectPresent ? createdTrainingEvents : {},
                    dataValues: {
                        ...initialDataValues,
                        'Present': isNewIndirectPresent // Ensure Present status is set correctly
                    }
                }
            }));
            setHasValidDate(prev => ({
                ...prev,
                [trackedEntityInstance]: isNewIndirectPresent ? (Object.values(createdTrainingEvents)[0] || muacEventId ? true : false) : false // Mark as having a valid date only if events were intended/created
            }));

            // Reset the form
            setNewIndirectData({
                id: '',
                trackInstanceId: '', // Resetting this is fine, as it's used for the add row state
                recordDate: '',
                track: '',
                inactive: '',
                beneficiaryStage: '',
                careGiver: '',
                careGiverAge: '',
                patientID: '',
                first_middleName: '',
                surname: '',
                dob: '',
                orgUnit: '',
                beneficiaryName: '',
                nonBeneficiaryName: '',
                sex: '',
                age: '',
                initialMuac: '',
                muacClassification: '',
                ben_facility_RegNo: '',
                directPatientID: '',
                beneficiaryType: '',
                muacColor: '#ffffff'
            });
            setIsNewEntry(prev => ({ ...prev, [newIndirectData.trackInstanceId]: false }));
            setIsAddingIndirect(false);
            setIsNewIndirectPresent(false); // Reset the new present checkbox state
            // Trigger data reload after successful save
            await fetchUpdatedIndirects();
            // setMessage('Indirect beneficiary successfully saved!');
            const index = 0;
            await handleIndirectPresentChange(trackedEntityInstance, isNewIndirectPresent, index);
            setMessage(
                <div>
                    Indirect beneficiary successfully saved!
                    {/* <button
                        onClick={() => {
                            // Manual click - only mark this one as present
                            if (newIndirectRef.current) {
                                handleIndirectPresentChange(newIndirectRef.current, true);
                            }
                        }}
                        className="btn btn-primary ms-2"
                        style={{ marginLeft: '20px' }}
                    // disabled={!newIndirectRef.current}
                    >
                        Enlist for Training
                    </button> */}
                </div>
            );

            setIsError(false);

        } catch { // Use any to accommodate potential error structure from fetch/axios
            console.error('Error saving indirect beneficiary:');
            setMessage('Error saving indirect beneficiary. ');
            setIsError(true);
        } finally {
            setLoading(false);
        }
    };

    // POST Date - create event 
    const handleReportDateSubmit = async (
        e: React.KeyboardEvent<HTMLInputElement> | React.FocusEvent<HTMLInputElement>,
        trackInstanceId: string
    ) => {
        // Handle both Enter key and blur events
        if (e.type === 'keydown') {
            const keyboardEvent = e as React.KeyboardEvent<HTMLInputElement>;
            if (keyboardEvent.key !== 'Enter') return;
        }

        const reportDate = editInputValues[trackInstanceId]?.reportDate;

        if (!reportDate) {
            setHasValidDate(prev => ({ ...prev, [trackInstanceId]: false }));
            setMessage('Date of training is required');
            setIsError(true);
            return;
        }

        // Parse trainingFilter string
        const selectedTrainings = trainingFilter
            .split(',')
            .map(t => t.trim())
            .filter(Boolean);

        try {
            // Object to store all created event IDs
            const eventsMap: Record<string, string> = {};
            let muacEventId = '';

            // 1. Create MUAC event if needed
            if (selectedTrainings.includes('Muac Assessment')) {
                try {
                    const muacPayload = {
                        events: [{
                            trackedEntityInstance: trackInstanceId,
                            program: 'n2iAPy3PGx7',
                            programStage: PROGRAM_STAGE_MAPPING['Muac Assessment'],
                            orgUnit: props.orgUnitId,
                            eventDate: reportDate,
                            status: 'ACTIVE',
                            dataValues: []
                        }]
                    };

                    const muacRes = await axios.post(
                        `${process.env.REACT_APP_DHIS2_BASE_URL}api/events`,
                        muacPayload
                    );
                    muacEventId = muacRes.data.response.importSummaries[0].reference;
                    eventsMap['Muac Assessment'] = muacEventId;
                } catch (error) {
                    console.error('Error creating MUAC event:', error);
                }
            }

            // 2. Create events for other trainings
            await Promise.all(
                selectedTrainings
                    .filter(t => t !== 'Muac Assessment')
                    .map(async training => {
                        const stage = PROGRAM_STAGE_MAPPING[training];
                        if (!stage) {
                            console.warn(`No programStage mapped for training: "${training}"`);
                            return;
                        }

                        const payload = {
                            events: [{
                                trackedEntityInstance: trackInstanceId,
                                program: 'n2iAPy3PGx7',
                                programStage: stage,
                                orgUnit: props.orgUnitId,
                                eventDate: reportDate,
                                status: 'ACTIVE',
                                dataValues: []
                            }]
                        };

                        const res = await axios.post(
                            `${process.env.REACT_APP_DHIS2_BASE_URL}api/events`,
                            payload
                        );
                        eventsMap[training] = res.data.response.importSummaries[0].reference;
                    })
            );

            setEditInputValues(prev => {
                const updatedValues = { ...prev };
                updatedValues[trackInstanceId] = {
                    ...(prev[trackInstanceId] || {}),
                    reportDate,
                    events: eventsMap,
                    ...(muacEventId ? { muacEventId } : {}),
                    dataValues: prev[trackInstanceId]?.dataValues || {}
                };
                return updatedValues;
            });

            setHasValidDate(prev => ({ ...prev, [trackInstanceId]: true }));
            setMessage('Date of Training Successfully Saved');
            setIsError(false);
        } catch (error) {
            console.error('Error creating training events:', error);
            setHasValidDate(prev => ({ ...prev, [trackInstanceId]: false }));
            setMessage('Failed to save training date');
            setIsError(true);
        }
    };

    const sendDataValueUpdate = async (
        trackInstanceId: string,
        dataElementName: string,
        value: string | boolean,
        training: string
    ) => {
        const currentValues = editInputValues[trackInstanceId] || {};
        const isMuacColumn = ['Oedema', 'Muac', 'Muac Classification'].includes(dataElementName);
        const programStage = isMuacColumn
            ? PROGRAM_STAGE_MAPPING['Muac Assessment']
            : PROGRAM_STAGE_MAPPING[training];

        if (!programStage || !dataElementName) return;

        const orgUnit = props.orgUnitId;
        const program = 'n2iAPy3PGx7';
        const reportDate = currentValues.reportDate;

        // Get event ID from editInputValues
        let eventId = currentValues.events?.[training];
        if (isMuacColumn) {
            eventId = currentValues.muacEventId;
        }

        // If no event ID but we have a report date, create a new event
        if (!eventId && reportDate) {
            try {
                const payload = {
                    events: [{
                        trackedEntityInstance: trackInstanceId,
                        program,
                        programStage,
                        orgUnit,
                        eventDate: reportDate,
                        status: 'ACTIVE',
                        dataValues: []
                    }]
                };

                const res = await axios.post(
                    `${process.env.REACT_APP_DHIS2_BASE_URL}api/events`,
                    payload
                );
                eventId = res.data.response.importSummaries[0].reference;

                // Update state with new event ID
                setEditInputValues(prev => {
                    const updated = { ...prev };
                    updated[trackInstanceId] = {
                        ...(updated[trackInstanceId] || {}),
                        events: {
                            ...(updated[trackInstanceId]?.events || {}),
                            [training]: eventId
                        },
                        ...(isMuacColumn ? { muacEventId: eventId } : {})
                    };
                    return updated;
                });
            } catch (error) {
                console.error('Error creating event:', error);
                return;
            }
        }

        // Prepare payload
        const dataElementId = dataElementIDsByFilter[training]?.[trackFilter]?.[dataElementName] ||
            dataElementIDsByFilter[training]?.[dataElementName];

        if (!dataElementId) {
            console.warn(`Missing dataElementId for ${dataElementName}`);
            return;
        }

        const payload = {
            event: eventId,
            orgUnit,
            program,
            programStage,
            trackedEntityInstance: trackInstanceId,
            status: 'ACTIVE',
            dataValues: [{
                dataElement: dataElementId,
                value: typeof value === 'boolean' ? (value ? 'true' : 'false') : value,
                providedElsewhere: false
            }]
        };

        try {
            await axios.put(
                `${process.env.REACT_APP_DHIS2_BASE_URL}api/events/${eventId}/${dataElementId}`,
                payload
            );

            // Update local state
            setEditInputValues(prev => {
                const updated = { ...prev };
                updated[trackInstanceId] = {
                    ...(updated[trackInstanceId] || {}),
                    dataValues: {
                        ...(updated[trackInstanceId]?.dataValues || {}),
                        [dataElementName]: value
                    }
                };
                return updated;
            });

            setMessage(`Data Element - ${dataElementName} successfully updated.`);
        } catch (error) {
            console.error('Failed to send data value update:', error);
            setMessage(`Data Element - ${dataElementName} update failed.`);
        }
    };

    //  handling present / absent indirect beneficiaries
    const handleIndirectPresentChange = async (indirectId: string, isPresent: boolean, index?: number) => {

        const parentId = selectedBeneficiary?.trackInstanceId;
        if (!parentId) {
            setMessage('No direct beneficiary selected');
            setIsError(true);
            return;
        }

        // Optimistic UI update
        setEditInputValues(prev => ({
            ...prev,
            [indirectId]: {
                ...(prev[indirectId] || {}),
                Present: isPresent
            }
        }));

        try {
            if (index > 0 && isPresent) {
                // Check if MUAC fields are filled
                const currentValues = editInputValues[indirectId] || {};
                const muacValue = currentValues.dataValues?.['Muac'];
                const oedemaValue = currentValues.dataValues?.['Oedema'];

                const parentData = editInputValues[parentId] || {};
                const reportDate = parentData.reportDate;
                console.log(`Report Date: ${reportDate}`);

                if (!reportDate) {
                    setMessage('Must have a training date set first');
                    setIsError(true);
                    return;
                }

                if (!muacValue || oedemaValue === undefined) {
                    setMessage('Please fill both Oedema and Muac fields before proceeding.');
                    setIsError(true);
                    return; // Don't proceed
                }

                // Lock this record for processing
                setCurrentlyProcessingId(indirectId);

                await Promise.all(
                    selectedTrainings.map(async training => {
                        const isMuac = training === 'Muac Assessment';
                        const stage = PROGRAM_STAGE_MAPPING[training];
                        if (!stage) return;

                        let eventId = editInputValues[indirectId]?.events?.[training];

                        if (!eventId) {
                            const payload = {
                                events: [
                                    {
                                        trackedEntityInstance: indirectId,
                                        program: 'n2iAPy3PGx7',
                                        programStage: stage,
                                        orgUnit: props.orgUnitId,
                                        eventDate: reportDate,
                                        status: 'ACTIVE',
                                        dataValues: []
                                    }
                                ]
                            };

                            const res = await axios.post(
                                `${process.env.REACT_APP_DHIS2_BASE_URL}api/events`,
                                payload
                            );

                            eventId = res.data.response.importSummaries[0].reference;

                            // Update local state with new event ID
                            setEditInputValues(prev => {
                                const updated = { ...prev };
                                updated[indirectId] = {
                                    ...(updated[indirectId] || {}),
                                    events: {
                                        ...(updated[indirectId]?.events || {}),
                                        [training]: eventId
                                    },
                                    ...(isMuac ? { muacEventId: eventId } : {})
                                };
                                return updated;
                            });
                        }

                        // Inherit all non-MUAC data values from parent
                        // Build inherited dataValues from parent
                        const dataValues = [];
                        const trainingDataElements =
                            dataElementIDsByFilter[training]?.[trackFilter] ||
                            dataElementIDsByFilter[training];

                        if (trainingDataElements) {
                            Object.entries(trainingDataElements).forEach(([label, dataElementId]) => {
                                if (!['Oedema', 'Muac', 'Muac Classification'].includes(label)) {
                                    const parentValue = parentData.dataValues?.[label];
                                    if (parentValue !== undefined) {
                                        dataValues.push({
                                            dataElement: dataElementId,
                                            value: typeof parentValue === 'boolean'
                                                ? (parentValue ? 'true' : 'false')
                                                : parentValue,
                                            providedElsewhere: false
                                        });
                                    }
                                }
                            });

                            // Update local state with inherited values
                            setEditInputValues(prev => ({
                                ...prev,
                                [indirectId]: {
                                    ...(prev[indirectId] || {}),
                                    reportDate: parentData.reportDate,
                                    dataValues: {
                                        ...Object.entries(parentData.dataValues || {}).reduce((acc, [key, value]) => {
                                            if (!['Oedema', 'Muac', 'Muac Classification'].includes(key)) {
                                                acc[key] = value;
                                            }
                                            return acc;
                                        }, {} as Record<string, string | boolean | number>),
                                        Present: true
                                    }
                                }
                            }));
                        }

                        // Only add Present=true for non-MUAC trainings
                        if (!isMuac) {
                            dataValues.push({
                                dataElement: 'FY2ZuB17VW3',
                                value: 'true',
                                providedElsewhere: false
                            });
                        }
                        // Update the event with the complete dataValues
                        await axios.put(
                            `${process.env.REACT_APP_DHIS2_BASE_URL}api/events/${eventId}`,
                            {
                                event: eventId,
                                trackedEntityInstance: indirectId,
                                program: 'n2iAPy3PGx7',
                                programStage: stage,
                                orgUnit: props.orgUnitId,
                                eventDate: reportDate,
                                status: 'ACTIVE',
                                dataValues
                            }
                        );
                    })
                );

                // Update local state with inherited values
                setEditInputValues(prev => {
                    const updated = { ...prev };
                    updated[indirectId] = {
                        ...(updated[indirectId] || {}),
                        reportDate,
                        dataValues: {
                            ...Object.entries(parentData.dataValues || {}).reduce((acc, [key, value]) => {
                                if (!['Oedema', 'Muac', 'Muac Classification'].includes(key)) {
                                    acc[key] = value;
                                }
                                return acc;
                            }, {} as Record<string, string | boolean | number>),
                            Present: true
                        }
                    };
                    return updated;
                });

                // After successful update, release the lock
                setCurrentlyProcessingId(null);

            } else {
                // Handle "Absent" case — delete events
                await Promise.all(
                    Object.values(editInputValues[indirectId]?.events || {}).map(eventId =>
                        axios.delete(`${process.env.REACT_APP_DHIS2_BASE_URL}api/events/${eventId}`)
                    )
                );
                // Reset state
                setEditInputValues(prev => ({
                    ...prev,
                    [indirectId]: {
                        ...(prev[indirectId] || {}),
                        reportDate: '',
                        events: {},
                        muacEventId: '',
                        dataValues: {
                            Present: false
                        }
                    }
                }));
            }

            setMessage(`Indirect beneficiary marked as ${isPresent ? 'present' : 'absent'}`);
        } catch (error) {
            console.error('Error updating indirect beneficiary:', error);
            setMessage('Failed to update indirect beneficiary status');
            setIsError(true);

            // Rollback optimistic state
            setEditInputValues(prev => ({
                ...prev,
                [indirectId]: {
                    ...(prev[indirectId] || {}),
                    Present: !isPresent
                }
            }));
        }
    };

    const canInteractWithRecord = (recordId: string, index: number) => {
        // Always allow interaction with direct beneficiary
        if (recordId === selectedBeneficiary?.trackInstanceId) return true;

        // Always allow interaction with first indirect beneficiary
        if (index === 0) return true;

        // For other records, apply the normal rules
        return (
            !currentlyProcessingId ||
            recordId === currentlyProcessingId ||
            editInputValues[recordId]?.dataValues?.['Present'] === true
        );
    };


    const loadAllAdditionalData = async () => {
        // 1. Abort previous request if still running and create new controller
        if (abortControllerRef.current) {
            abortControllerRef.current.abort('New data load requested');
        }
        abortControllerRef.current = new AbortController();
        const { signal } = abortControllerRef.current; // Get signal for THIS execution

        setIsLoadingData(true); // Set loading TRUE at the start
        setLoadingAdditionalData(true); // If this state is used
        setMessage('');
        setIsError(false);

        const newFetchedDates: Record<string, FetchedData> = {};
        const batchSize = 50; // Adjust batch size as needed

        try {
            for (let i = 0; i < filteredData.length; i += batchSize) {
                // Throw if aborted before starting batch
                signal.throwIfAborted();

                const batch = filteredData.slice(i, i + batchSize);
                const batchResults = await Promise.all(batch.map(async (activity) => {
                    // Inside map, check signal again before fetch
                    signal.throwIfAborted();
                    try {
                        const additionalData = await fetchAdditionalData(
                            activity.trackInstanceId,
                            trainingFilter,
                            trackFilter,
                            signal // Pass signal
                        );
                        return { id: activity.trackInstanceId, data: additionalData };
                    } catch (error) {
                        // Handle errors from fetchAdditionalData including aborts
                        if (axios.isCancel(error)) {
                            // Don't treat abort as a data error, return null or identifier
                            return { id: activity.trackInstanceId, data: null, aborted: true };
                        }
                        console.error(`Failed to fetch data for ${activity.trackInstanceId}:`, error);
                        // Return fetched data structure with error indicator or default
                        return { id: activity.trackInstanceId, data: { reportDate: '', dueDate: '', eventId: '', muacEventId: '', dataValues: {}, events: {} }, error: true };
                    }
                }));

                // Process batch results only if not aborted during Promise.all
                signal.throwIfAborted();

                batchResults.forEach(result => {
                    // Add to newFetchedDates only if data exists and wasn't aborted
                    if (result.data && !result.aborted) {
                        newFetchedDates[result.id] = result.data;
                    }
                });
            }

            // Final state update only if the entire process wasn't aborted
            signal.throwIfAborted();

            setFetchedDates(prev => ({ ...prev, ...newFetchedDates })); // Merge carefully

            // Update hasValidDate based on successfully fetched data
            const validDatesUpdate: Record<string, boolean> = {};
            Object.entries(newFetchedDates).forEach(([id, data]) => {
                validDatesUpdate[id] = !!data.reportDate; // Or based on eventId/presence
            });
            setHasValidDate(prev => ({ ...prev, ...validDatesUpdate }));

        } catch (error) {
            if (axios.isCancel(error)) {
                console.log('loadAllAdditionalData aborted:');
            } else {
                // Handle other errors during the loop or processing
                console.error("Error loading additional data:", error);
                // setMessage("Failed to load some event details.");
                setIsError(true);
            }
        } finally {
            // Set loading false ONLY if this specific signal was NOT aborted
            if (!signal.aborted) {
                setIsLoadingData(false);
                setLoadingAdditionalData(false);
                // Clear the ref only if this instance finished normally
                if (abortControllerRef.current && abortControllerRef.current.signal === signal) {
                    abortControllerRef.current = null;
                }
            }
        }
    };

    // Call this whenever filteredData or trainingFilter changes
    const fetchAdditionalData = async (
        trackInstanceId: string,
        trainingFilter: string,
        trackFilter: string,
        signal?: AbortSignal): Promise<FetchedData> => {

        const programStageMap = {
            'Livelihood': 'H0vCgsI1d4M',
            'Nutrition': 'RXTq2YFOH5c',
            'Water Sanitation & Hygiene': 'bTVReRuHapT',
            'Muac Assessment': 'HEukVrLC2dT'
        };

        // Split the trainingFilter string into an array of selected training names
        const selectedTrainingsArray = trainingFilter.split(',').map(t => t.trim()).filter(Boolean);

        // Get the program stage IDs for the selected trainings (excluding MUAC for this array)
        const selectedTrainingStageIds = selectedTrainingsArray
            .map(training => programStageMap[training])
            .filter(stageId => stageId && stageId !== programStageMap['Muac Assessment']);


        let reportDate = '';
        let dueDate = '';
        // Use an object to store event IDs for each selected training program stage
        const trainingEventIds: Record<string, string> = {};
        const dataValues: { [key: string]: string | boolean } = {}; // Use boolean type for checkboxes
        let muacEventId = '';

        // setIsLoadingData(true);
        try {
            // Check signal before making the request
            signal.throwIfAborted();

            // Fetch all relevant events at once for the tracked entity instance
            const response = await axios.get(
                `${process.env.REACT_APP_DHIS2_BASE_URL}api/trackedEntityInstances/${trackInstanceId}.json`,
                {
                    params: {
                        program: 'n2iAPy3PGx7',
                        fields: 'enrollments[events[event,eventDate,dueDate,programStage,dataValues[dataElement,value]]'
                    }
                }
            );

            // Check signal again after request returns, before processing
            signal.throwIfAborted();
            const events = response.data.enrollments?.[0]?.events || [];

            // Process each event found
            events.forEach((event: any) => {
                // Check if this event corresponds to one of the selected training program stages
                const isSelectedTrainingEvent = selectedTrainingStageIds.includes(event.programStage);

                // Check if this is the MUAC event
                const isMuacEvent = event.programStage === programStageMap['Muac Assessment'];

                if (isSelectedTrainingEvent) {
                    // Find the training name corresponding to this event's program stage
                    const trainingName = Object.keys(programStageMap).find(key => programStageMap[key] === event.programStage);

                    if (trainingName) {
                        // Use the most recent event date and due date found among the selected training events
                        if (event.eventDate) {
                            // Keep the latest date if multiple training events have dates
                            if (!reportDate || new Date(event.eventDate) > new Date(reportDate)) {
                                reportDate = event.eventDate;
                            }
                        }
                        if (event.dueDate) {
                            // Keep the latest due date if multiple training events have due dates
                            if (!dueDate || new Date(event.dueDate) > new Date(dueDate)) {
                                dueDate = event.dueDate;
                            }
                        }


                        trainingEventIds[trainingName] = event.event; // Store the event ID for this specific training

                        // Process data values for this training event
                        event.dataValues?.forEach((dv: any) => {
                            if (dv.dataElement === 'FY2ZuB17VW3') {
                                dataValues['Present'] = dv.value === 'true';
                            }
                            Object.entries(dataValueMapping).forEach(([accessorKey, label]) => {
                                // Find the correct dataElementMapping based on the *current event's training program stage* and track
                                const trainingSpecificMapping = dataElementMapping[trainingName];

                                if (!trainingSpecificMapping) return; // Skip if no mapping for this training

                                const expectedId = (trackFilter && trainingSpecificMapping[trackFilter]?.[label]) // Check track specific first for Livelihood
                                    || trainingSpecificMapping[label]; // Then general mapping for other trainings

                                if (expectedId === dv.dataElement) {
                                    // Prioritize data values from more recent events if multiple events for the same training are found (though typically there should only be one per date/stage)
                                    // For simplicity here, we'll just let later data values overwrite earlier ones if duplicates exist across events for the same training.
                                    dataValues[label] = dv.value === 'true' ? true : dv.value === 'false' ? false : dv.value;
                                }
                            });
                        });
                    }
                } else if (isMuacEvent) {
                    // MUAC event processing remains similar
                    // Use MUAC date/due date only if no training date/due date is found yet
                    if (!reportDate && event.eventDate) {
                        reportDate = event.eventDate;
                    }
                    if (!dueDate && event.dueDate) {
                        dueDate = event.dueDate;
                    }
                    muacEventId = event.event; // Store MUAC event ID

                    // Process MUAC data values
                    event.dataValues?.forEach((dv: any) => {
                        Object.entries(muacDataElementMapping).forEach(([label, deId]) => {
                            if (deId === dv.dataElement) {
                                // Convert 'true'/'false' strings to booleans for checkboxes
                                dataValues[label] = dv.value === 'true' ? true : dv.value === 'false' ? false : dv.value;
                            }
                        });
                    });
                }
            });

            // For indirect beneficiaries, inherit non-MUAC data from direct beneficiary
            const isIndirect = props.orgUnitDetails.some(b =>
                b.trackInstanceId === trackInstanceId &&
                b.directPatientID &&
                b.directPatientID !== ''
            );
            if (isIndirect) {
                const directBeneficiary = props.orgUnitDetails.find(b =>
                    b.patientID === props.orgUnitDetails.find(b => b.trackInstanceId === trackInstanceId)?.directPatientID
                );
                if (directBeneficiary) {
                    // Fetch data for the direct beneficiary specifically to inherit values
                    // Pass the original selectedTrainingsArray to the recursive call
                    const directData = await fetchAdditionalData(directBeneficiary.trackInstanceId, selectedTrainingsArray.join(','), trackFilter, signal);


                    if (directData) {
                        // Only inherit non-MUAC data values
                        Object.entries(directData.dataValues || {}).forEach(([key, value]) => {
                            // Only inherit if the indirect beneficiary doesn't already have a value for this data element
                            // and the data element is not for MUAC
                            if (!['Oedema', 'Muac', 'Muac Classification'].includes(key) && dataValues[key] === undefined) {
                                dataValues[key] = value;
                            }
                        });
                        // Inherit reportDate and dueDate if not present in the indirect's events
                        if (!reportDate && directData.reportDate) {
                            reportDate = directData.reportDate;
                        }
                        if (!dueDate && directData.dueDate) {
                            dueDate = directData.dueDate;
                        }

                        // Inherit training event IDs and data values from the direct beneficiary
                        Object.entries(directData.events || {}).forEach(([training, eventId]) => {
                            if (!trainingEventIds[training]) { // Only inherit if the indirect beneficiary doesn't have their own event for this training
                                trainingEventIds[training] = eventId;
                            }
                        });

                    }
                }
            }
            return {
                reportDate,
                dueDate,
                eventId: Object.values(trainingEventIds)[0] || muacEventId, // Return one eventId (e.g., the first training one, or MUAC if no training) - this might need refinement depending on how eventId is used downstream if multiple exist
                muacEventId,
                events: trainingEventIds, // Store event IDs per training program
                dataValues, // Combined data values from all relevant events
            };
            // Always return empty data initially
            // return {
            //     reportDate: '',
            //     dueDate: '',
            //     eventId: '',
            //     muacEventId: '',
            //     dataValues: {},
            //     events: {}
            // };
        } catch (error) {
            // setIsLoadingData(false);
            console.error('Error fetching additional data:', error);
            // Ensure default structure is returned even on error
            return { reportDate: '', dueDate: '', eventId: '', muacEventId: '', dataValues: {}, events: {} };
        }
    };

    const handleFilterChange = async (training) => {
        let newSelected;


        if (training === 'Livelihood') {
            newSelected = ['Livelihood'];
            // handleRecordClick()
        } else {
            // If Livelihood is already selected, start fresh
            if (selectedTrainings.includes('Livelihood')) {
                newSelected = [training];
            } else {
                // Toggle selection for Water Sanitation & Hygiene or Nutrition
                newSelected = selectedTrainings.includes(training)
                    ? selectedTrainings.filter(t => t !== training)
                    : [...selectedTrainings, training];
            }
        }
        setSelectedTrainings(newSelected);
        setTrainingFilter(newSelected.join(','));
        // Set program stage for compatibility (optional, can be removed if not needed)
        setSelectedProgramStage(newSelected.length === 1 ? newSelected[0] : '');

        // Update columns for all selected trainings
        let allCols = [];
        newSelected.forEach(filter => {
            allCols = [...allCols, ...getAdditionalColumns(filter)];
        });

        // Add unified date column
        if (newSelected.length > 0) {
            allCols.unshift({
                Header: 'Date of Training',
                accessor: 'reportDate',
                headerClassName: 'additional-header-cell date-column',
                className: 'date-column',
                minWidth: 100,
                training: 'Date'
            });
        }

        // Add Action column only once if any trainings are selected
        if (newSelected.length > 0) {
            allCols.push({
                Header: "Add / Edit Event",
                accessor: 'addEditEvent',
                headerClassName: 'additional-header-cell actions-header',
                className: 'actions-cell',
                minWidth: 140,
                width: 140,
                training: 'Action'
            });
        }

        setAdditionalColumns(allCols);

        // 1. Abort any previous/ongoing fetch controlled by the main ref
        if (abortControllerRef.current) {
            abortControllerRef.current.abort('Training filter changed');
            console.log("Aborted previous fetch due to filter change.");
        }
        // 2. Create a new controller and signal for *this* fetch operation
        abortControllerRef.current = new AbortController();
        const { signal } = abortControllerRef.current;

        // Fetch additional data for all rows for each selected training
        const allFetchedDates = {};
        for (const filter of newSelected) {
            const updatedFetchedDates = await Promise.all(
                filteredData.map(async (activity) => {
                    const additionalData = await fetchAdditionalData(activity.trackInstanceId, filter, trackFilter, signal);
                    return {
                        trackInstanceId: activity.trackInstanceId,
                        reportDate: additionalData.reportDate,
                        dueDate: additionalData.dueDate,
                        eventId: additionalData.eventId,
                        dataValues: additionalData.dataValues || {}
                    };
                })
            );
            updatedFetchedDates.forEach(({ trackInstanceId, reportDate, dueDate, eventId, dataValues }) => {
                // Merge data for each trackInstanceId
                allFetchedDates[trackInstanceId] = {
                    ...(allFetchedDates[trackInstanceId] || {}),
                    reportDate,
                    dueDate,
                    eventId,
                    dataValues: {
                        ...(allFetchedDates[trackInstanceId]?.dataValues || {}),
                        ...dataValues
                    }
                };
            });
        }
        setFetchedDates(allFetchedDates);
    };
    // Muac Classification
    const computeMuacClassification = (muac: string, stage: string): string => {
        const muacValue = parseFloat(muac);
        if (isNaN(muacValue)) return '';

        if (stage === 'Child') {
            if (muacValue < 11.5) return 'Severe <11.5 cm (Red)';
            if (muacValue < 12.5) return 'Moderate >=11.5 - < 12.5 cm (Yellow)';
            return 'Normal ≥12.5 cm (Green)';
        }

        if (stage === 'Adult') {
            if (muacValue < 21) return 'Less than 21 cm (red)';
            if (muacValue < 23) return 'Less than 23 cm greater than 21 cm (yellow)';
            return 'Equals to or greater than 23 cm (green)';
        }

        return '';
    };

    const handleEditInputChange = (
        trackInstanceId: string,
        accessor: string,
        value: string | boolean
    ) => {
        // if (!hasValidDate[trackInstanceId]) {
        //     setMessage('Please set Date of Training first');
        //     setIsError(true);
        //     return;
        // }
        setEditInputValues(prev => ({
            ...prev,
            [trackInstanceId]: {
                ...(prev[trackInstanceId] || {}), // Keep other values for this row
                [accessor]: value // Update the specific field
            }
        }));

        const colMeta = additionalColumns.find(col => dataValueMapping[col.accessor] === accessor);
        const training = colMeta?.training || selectedTrainings[0];

        // Send immediately for checkboxes
        if (typeof value === 'boolean') {
            sendDataValueUpdate(trackInstanceId, accessor, value, colMeta.training);
        }

    };
    // You might need a specific handler for MUAC if it needs linked updates (like classification)
    const handleEditMuacChange = (trackInstanceId: string, muacValue: string, classification: string) => {
        setEditInputValues(prev => ({
            ...prev,
            [trackInstanceId]: {
                ...(prev[trackInstanceId] || {}),
                [dataValueMapping['muac_num']]: muacValue,
                [dataValueMapping['muacClassification_text']]: classification,
            }
        }));
    };

    // Add this at the top of your file with other utility functions
    const formatDateToDDMMYY = (dateString: string): string => {
        if (!dateString) return '';

        try {
            const date = new Date(dateString);
            if (isNaN(date.getTime())) return dateString; // Return original if invalid

            const day = String(date.getDate()).padStart(2, '0');
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const year = String(date.getFullYear()).slice(-2);

            return `${day}/${month}/${year}`;
        } catch {
            return dateString; // Return original if parsing fails
        }
    };

    const renderTableRows = () => {
        // No data case
        if (!filteredData || filteredData.length === 0) {
            return (
                <tr>
                    <td colSpan={columnsVis.filter(c => c.visible).length + additionalColumns.length + 1}>
                        No data available for the selected Entry, Please add new Beneficially
                    </td>
                </tr>
            );
        }

        return filteredData.map((activity, index) => {
            const fetchedData: FetchedData =
                fetchedDates[activity.trackInstanceId] ||
                {
                    reportDate: '',
                    dueDate: '',
                    eventId: '',
                    muacEventId: '',
                    dataValues: {},
                    events: {}
                };
            // Determine if this is a new entry
            const isNew = isNewEntry[activity.trackInstanceId] || false;

            return (
                <tr
                    key={activity.trackInstanceId || index}
                    onClick={e => {
                        e.stopPropagation();
                        handleRecordClick(activity);
                        setBeneficiarySearch(activity.patientID)
                    }}
                    className={selectedBeneficiary?.trackInstanceId === activity.trackInstanceId ? 'highlight-row' : ''}
                >
                    {/* 1 Original columns */}
                    {columnsVis
                        .filter(c => c.visible)
                        .map(c => {
                            const value = (activity as any)[c.accessor];
                            // Format date columns
                            if (c.accessor === 'recordDate' || c.accessor === 'dob') {
                                return <td key={c.accessor}>{formatDateToDDMMYY(value)}</td>;
                            }
                            return <td key={c.accessor}>{value}</td>;
                        })}

                    {/* 2 Additional columns */}
                    {additionalColumns.filter(col => topicsVis[col.accessor]).map(col => {
                        const isAction = col.accessor === 'addEditEvent';
                        const isCheckbox = col.accessor.includes('checkBox');
                        // Determine class: actions-cell, or your custom className, or numeric-cell
                        const cellClass = isAction
                            ? 'actions-cell'
                            : col.className
                                ? col.className
                                : isCheckbox
                                    ? 'numeric-cell'
                                    : '';

                        // Apply minWidth inline if provided
                        const style: React.CSSProperties = col.minWidth
                            ? { minWidth: col.minWidth }
                            : {};

                        // Editing mode?
                        const inEdit = editableRows[activity.trackInstanceId] && !isAction;

                        return (
                            <td key={col.accessor} className={cellClass} style={style}>
                                {inEdit ? (
                                    // In‑row inputs when editing (excluding addEditEvent)
                                    col.accessor === 'reportDate' ? (
                                        <input
                                            type="date"
                                            // value={fetchedData.reportDate.split('T')[0] || ''}
                                            // value={String(fetchedData.dataValues[dataValueMapping[col.accessor]] || '')}
                                            value={String(editInputValues[activity.trackInstanceId]?.reportDate || '')}
                                            onChange={e =>
                                                handleEditInputChange(
                                                    activity.trackInstanceId,
                                                    'reportDate',
                                                    e.target.value
                                                )
                                            }
                                            onKeyDown={e =>
                                                handleReportDateSubmit(e, activity.trackInstanceId)
                                            }
                                            onBlur={e =>
                                                handleReportDateSubmit(e, activity.trackInstanceId)
                                            }
                                            title="Select the date and click outside the input field to save."
                                        />
                                    ) : isCheckbox ? (
                                        <input
                                            type="checkbox"
                                            disabled={!hasValidDate[activity.trackInstanceId]}
                                            className="form-check-input"
                                            // checked={fetchedData.dataValues[dataValueMapping[col.accessor]] === true ||
                                            //     fetchedData.dataValues[dataValueMapping[col.accessor]] === 'true'}
                                            // checked={editInputValues[activity.trackInstanceId]?.[col.accessor] === true}
                                            checked={!!editInputValues[activity.trackInstanceId]?.[dataValueMapping[col.accessor]]}
                                            onChange={e =>
                                                handleEditInputChange(
                                                    activity.trackInstanceId,
                                                    dataValueMapping[col.accessor],
                                                    e.target.checked
                                                )
                                            }
                                        />
                                    ) : (
                                        // all other non-checkbox editors: selects / text inputs
                                        (() => {
                                            // dropdown for appliedLessons
                                            if (col.accessor === 'appliedLessons_dropdown') {
                                                return (
                                                    <select
                                                        className="form-select"
                                                        // value={String(fetchedData.dataValues[dataValueMapping[col.accessor]] || '')}
                                                        value={String(editInputValues[activity.trackInstanceId]?.[col.accessor] || '')}
                                                        onChange={e =>
                                                            handleEditInputChange(
                                                                activity.trackInstanceId,
                                                                dataValueMapping[col.accessor],
                                                                e.target.value
                                                            )
                                                        }
                                                        onKeyDown={e => {
                                                            if (e.key === 'Enter') {
                                                                const training = col.training || selectedTrainings[0];
                                                                sendDataValueUpdate(
                                                                    activity.trackInstanceId,
                                                                    dataValueMapping[col.accessor],
                                                                    e.currentTarget.value === 'Yes',
                                                                    training
                                                                );
                                                            }
                                                        }}
                                                    >
                                                        <option value="">Select</option>
                                                        <option value="Yes">Yes</option>
                                                        <option value="No">No</option>
                                                    </select>
                                                );
                                            }
                                            // dropdown for beneficiary category
                                            if (col.accessor === 'Beneficiary_Category_dropDown') {
                                                return (
                                                    <select
                                                        className="form-select"
                                                        // value={String(fetchedData.dataValues[dataValueMapping[col.accessor]] || '')}
                                                        value={String(editInputValues[activity.trackInstanceId]?.[col.accessor] || '')}
                                                        onChange={e =>
                                                            handleEditInputChange(
                                                                activity.trackInstanceId,
                                                                dataValueMapping[col.accessor],
                                                                e.target.value
                                                            )
                                                        }
                                                        onKeyDown={e => {
                                                            if (e.key === 'Enter') {
                                                                const training = col.training || selectedTrainings[0];
                                                                sendDataValueUpdate(
                                                                    activity.trackInstanceId,
                                                                    dataValueMapping[col.accessor],
                                                                    e.currentTarget.value === 'Yes',
                                                                    training
                                                                );
                                                            }
                                                        }}
                                                    >
                                                        <option value="">Select</option>
                                                        <option value="Pregnant">Pregnant</option>
                                                        <option value="Lactating">Lactating</option>
                                                        <option value="Care Giver">Care Giver</option>
                                                    </select>
                                                );
                                            }
                                            // numeric text inputs (e.g. others_text)
                                            if (col.accessor.includes('no_input')) {
                                                return (
                                                    <input
                                                        type="number"
                                                        // value={String(fetchedData.dataValues[dataValueMapping[col.accessor]] || '')}
                                                        value={String(editInputValues[activity.trackInstanceId]?.[col.accessor] || '')}
                                                        onKeyDown={e => {
                                                            if (e.key === 'Enter') {
                                                                const training = col.training || selectedTrainings[0];
                                                                sendDataValueUpdate(
                                                                    activity.trackInstanceId,
                                                                    dataValueMapping[col.accessor],
                                                                    e.currentTarget.value === 'Yes',
                                                                    training
                                                                );
                                                            }
                                                        }}
                                                        onChange={e =>
                                                            handleEditInputChange(
                                                                activity.trackInstanceId,
                                                                dataValueMapping[col.accessor],
                                                                e.target.value
                                                            )
                                                        }
                                                    />
                                                );
                                            }
                                            // numeric muac input
                                            if (col.accessor === 'muac_num') {
                                                const beneficiaryStage = activity.beneficiaryStage;
                                                console.log('Data value mapping:', activity.beneficiaryStage);

                                                return (
                                                    <input
                                                        type="text"
                                                        inputMode="numeric"
                                                        pattern="[0-9]*"
                                                        className="form-input"
                                                        // value={String(fetchedData.dataValues[dataValueMapping[col.accessor]] || '')}
                                                        // value={String(editInputValues[activity.trackInstanceId]?.[col.accessor] || '')}
                                                        value={String(editInputValues[activity.trackInstanceId]?.[dataValueMapping['muac_num']] || '')}
                                                        onChange={(e) => {
                                                            // strip out anything that isn’t a digit
                                                            const onlyDigits = e.target.value.replace(/\D/g, '');
                                                            const classification = computeMuacClassification(
                                                                onlyDigits,
                                                                beneficiaryStage
                                                            );

                                                            // Update both muac_num and muacClassification in memory
                                                            handleEditMuacChange(
                                                                activity.trackInstanceId,
                                                                onlyDigits,
                                                                classification
                                                            );
                                                            // setMuacClass(classification);
                                                        }}
                                                        onKeyDown={(e) => {
                                                            // allow only digits, Backspace, Delete, arrows, Tab
                                                            if (
                                                                !/[0-9]/.test(e.key) &&
                                                                e.key !== 'Backspace' &&
                                                                e.key !== 'Delete' &&
                                                                e.key !== 'ArrowLeft' &&
                                                                e.key !== 'ArrowRight' &&
                                                                e.key !== 'Tab' &&
                                                                e.key !== 'Enter'
                                                            ) {
                                                                e.preventDefault();
                                                            }

                                                            if (e.key === 'Enter') {
                                                                const training = col.training || selectedTrainings[0];
                                                                sendDataValueUpdate(
                                                                    activity.trackInstanceId,
                                                                    dataValueMapping[col.accessor],
                                                                    // fetchedData.dataValues[dataValueMapping[col.accessor]],
                                                                    editInputValues[activity.trackInstanceId]?.[dataValueMapping['muac_num']],
                                                                    training
                                                                );

                                                                // Save Classification
                                                                sendDataValueUpdate(
                                                                    activity.trackInstanceId,
                                                                    dataValueMapping['muacClassification'],
                                                                    fetchedData.dataValues[dataValueMapping['muacClassification']],
                                                                    training
                                                                );
                                                                console.log('Classification : ', fetchedData.dataValues[dataValueMapping['muacClassification']])
                                                            }
                                                        }}
                                                        placeholder="Enter MUAC"
                                                    />
                                                );
                                            }
                                            // fallback text input
                                            return (
                                                <input
                                                    type="text"
                                                    // value={String(fetchedData.dataValues[dataValueMapping[col.accessor]] || '')}
                                                    value={String(editInputValues[activity.trackInstanceId]?.[col.accessor] || '')}
                                                    onKeyDown={e => {
                                                        if (e.key === 'Enter') {
                                                            const training = col.training || selectedTrainings[0];
                                                            sendDataValueUpdate(
                                                                activity.trackInstanceId,
                                                                dataValueMapping[col.accessor],
                                                                e.currentTarget.value === 'Yes',
                                                                training
                                                            );
                                                        }
                                                    }}
                                                    onChange={e =>
                                                        handleEditInputChange(
                                                            activity.trackInstanceId,
                                                            dataValueMapping[col.accessor],
                                                            e.target.value
                                                        )
                                                    }
                                                    title="Press Enter to save the MUAC value"
                                                />
                                            );
                                        })()
                                    )
                                ) : (
                                    (activity as any)[col.accessor] || ''

                                )}
                            </td>
                        );
                    })}
                </tr>
            );
        });
    };

    const renderIndirectRows = () => {
        // const inheritedCols = additionalColumns.filter(c => c.accessor !== 'addEditEvent' && topicsVis[c.accessor]);
        const inheritedCols = additionalColumns.filter(c => topicsVis[c.accessor] && c.accessor !== 'addEditEvent');
        if (!indirectBeneficiaries.length) {
            return (
                <tr>
                    <td
                        colSpan={
                            columnsVis.filter(c => c.visible).length +
                            inheritedCols.length +
                            1
                        }
                        className="text-center"
                    >
                        No indirect beneficiaries found for this record
                    </td>
                </tr>
            );
        }
        // grab the parent’s fetched record so we can inherit its dates & dataValues
        const parentId = selectedBeneficiary?.trackInstanceId!;
        const parentData = editInputValues[parentId] || {
            reportDate: '',
            dataValues: {}
        }

        return (
            <>
                {indirectBeneficiaries.map((ben, index) => {
                    const isDirectBeneficiaryRow = ben.trackInstanceId === selectedBeneficiary?.trackInstanceId;
                    let finalIsDisabled;

                    if (isDirectBeneficiaryRow) {
                        finalIsDisabled = false;
                    } else if (index === 0) {
                        finalIsDisabled = false;
                    } else {

                        finalIsDisabled = !canInteractWithRecord(ben.trackInstanceId, index); // Referring to function at 
                    }

                    // Ensure you use this 'finalIsDisabled' for styling and disabling inputs within the row
                    const isDisabled = finalIsDisabled;

                    const isNew = isNewEntry[ben.trackInstanceId] || false;
                    const isPresent = editInputValues[ben.trackInstanceId]?.[dataValueMapping['Present']] === true ||
                        editInputValues[ben.trackInstanceId]?.[dataValueMapping['Present']] === 'true';
                    const rowClass = !(editInputValues[ben.trackInstanceId]?.dataValues?.['Present'] === true) ? 'unchecked-record' : '';

                    return (
                        <tr
                            key={ben.trackInstanceId}
                            className={`${rowClass} ${isDisabled ? 'disabled-row' : ''}`}
                            style={{
                                ...(!isPresent ? { position: 'relative' } : {}),
                                opacity: isDisabled ? 0.5 : 1,
                                pointerEvents: isDisabled ? 'none' : 'auto'
                            }}
                        >
                            {/* Present/Absent checkbox */}
                            <td>
                                <input
                                    type="checkbox"
                                    checked={editInputValues[ben.trackInstanceId]?.dataValues?.['Present'] === true}
                                    onChange={e =>
                                        handleIndirectPresentChange(
                                            ben.trackInstanceId,
                                            e.target.checked,
                                            index
                                        )
                                    }
                                    disabled={isDisabled}
                                />
                            </td>

                            {/* 1 Original columns */}

                            {columnsVis.filter(c => c.visible).map(c => {
                                const value = (ben as any)[c.accessor];
                                // Format date columns
                                if (c.accessor === 'recordDate' || c.accessor === 'dob') {
                                    return <td key={c.accessor}>{formatDateToDDMMYY(value)}</td>;
                                }
                                return <td key={c.accessor}>{value}</td>;
                            })}

                            {/* 2 Additional columns (read‑only, inherited) */}

                            {inheritedCols.map(col => {
                                const isAction = col.accessor === 'addEditEvent';
                                const isCheckbox = col.accessor.includes('checkBox');
                                const isMuacColumn = col.accessor === 'muac_num' || col.accessor === 'oedema_checkBox';
                                const cellClass = isAction
                                    ? 'actions-cell'
                                    : col.className
                                        ? col.className
                                        : isCheckbox
                                            ? 'numeric-cell'
                                            : '';
                                const style: React.CSSProperties = col.minWidth
                                    ? { minWidth: col.minWidth }
                                    : {};

                                // Only allow editing for MUAC columns
                                const inEdit = editableRows[ben.trackInstanceId] && isMuacColumn;

                                return (
                                    <td key={col.accessor} className={cellClass} style={style}>
                                        {inEdit ? (
                                            // Editing mode - only for MUAC columns
                                            col.accessor === 'muac_num' ? (
                                                <input
                                                    type="text"
                                                    inputMode="numeric"
                                                    pattern="[0-9]*"
                                                    className="form-input"
                                                    // value={String(fetchedData.dataValues[dataValueMapping[col.accessor]] || '')}
                                                    // value={String(editInputValues[activity.trackInstanceId]?.[col.accessor] || '')}
                                                    value={String(editInputValues[ben.trackInstanceId]?.[dataValueMapping['muac_num']] || '')}
                                                    onChange={(e) => {
                                                        // strip out anything that isn’t a digit
                                                        const onlyDigits = e.target.value.replace(/\D/g, '');
                                                        const classification = computeMuacClassification(
                                                            onlyDigits,
                                                            ben.beneficiaryStage
                                                        );
                                                        // Update both muac_num and muacClassification in memory
                                                        handleEditMuacChange(
                                                            ben.trackInstanceId,
                                                            onlyDigits,
                                                            classification
                                                        );
                                                        // setMuacClass(classification);
                                                    }}
                                                    onKeyDown={(e) => {
                                                        // allow only digits, Backspace, Delete, arrows, Tab
                                                        if (
                                                            !/[0-9]/.test(e.key) &&
                                                            e.key !== 'Backspace' &&
                                                            e.key !== 'Delete' &&
                                                            e.key !== 'ArrowLeft' &&
                                                            e.key !== 'ArrowRight' &&
                                                            e.key !== 'Tab' &&
                                                            e.key !== 'Enter'
                                                        ) {
                                                            e.preventDefault();
                                                        }

                                                        if (e.key === 'Enter') {
                                                            const training = col.training || selectedTrainings[0];
                                                            sendDataValueUpdate(
                                                                ben.trackInstanceId,
                                                                dataValueMapping[col.accessor],
                                                                // fetchedData.dataValues[dataValueMapping[col.accessor]],
                                                                editInputValues[ben.trackInstanceId]?.[dataValueMapping['muac_num']],
                                                                training
                                                            );
                                                            // Save Classification
                                                            sendDataValueUpdate(
                                                                ben.trackInstanceId,
                                                                dataValueMapping['muacClassification'],
                                                                editInputValues[ben.trackInstanceId]?.[dataValueMapping['muac_num']],
                                                                training
                                                            );

                                                        }
                                                    }}
                                                    placeholder="Enter MUAC"
                                                    // style={{
                                                    //     ...style,
                                                    //     opacity: (editInputValues[ben.trackInstanceId]?.dataValues?.['Present'] === false) ? 0.5 : 1,
                                                    //     pointerEvents: (editInputValues[ben.trackInstanceId]?.dataValues?.['Present'] === false) ? 'none' : 'auto'
                                                    // }}
                                                    title="Press Enter to save the MUAC value"
                                                />
                                            ) : col.accessor === 'oedema_checkBox' ? (
                                                // Replace the oedema checkbox rendering with:
                                                <input
                                                    type="checkbox"
                                                    // checked={editInputValues[ben.trackInstanceId]?.dataValues?.[col.accessor] === true ||
                                                    //     editInputValues[ben.trackInstanceId]?.dataValues?.[col.accessor] === 'true'
                                                    // }
                                                    checked={!!editInputValues[ben.trackInstanceId]?.[dataValueMapping[col.accessor]]}
                                                    onChange={e => {
                                                        const hasDate = editInputValues[parentId]?.reportDate
                                                        console.log(`hasDate: ${hasDate}`);
                                                        handleEditInputChange(
                                                            ben.trackInstanceId,
                                                            'Oedema',
                                                            e.target.checked
                                                        );

                                                        sendDataValueUpdate(
                                                            ben.trackInstanceId,
                                                            'Oedema',
                                                            e.target.checked,
                                                            'Muac Assessment'
                                                        );
                                                    }}
                                                // style={{
                                                //     ...style,
                                                //     opacity: (editInputValues[ben.trackInstanceId]?.dataValues?.['Present'] === false) ? 0.5 : 1,
                                                //     pointerEvents: (editInputValues[ben.trackInstanceId]?.dataValues?.['Present'] === false) ? 'none' : 'auto'
                                                // }}
                                                />
                                            ) : null
                                        ) :
                                            // Static display when NOT editing
                                            (
                                                (() => {
                                                    const parentId = selectedBeneficiary?.trackInstanceId!;
                                                    if (col.accessor === 'reportDate') {
                                                        return parentData.reportDate || '';
                                                        //fetchedDates[parentId]?.reportDate?.split('T')[0] || '';
                                                    } else if (col.accessor in dataValueMapping) {
                                                        if (col.accessor === 'muac_num') {
                                                            return (
                                                                <input
                                                                    type="text"
                                                                    inputMode="numeric"
                                                                    pattern="[0-9]*"
                                                                    className="form-input"
                                                                    // value={String(fetchedData.dataValues[dataValueMapping[col.accessor]] || '')}
                                                                    // value={String(editInputValues[activity.trackInstanceId]?.[col.accessor] || '')}
                                                                    value={String(editInputValues[ben.trackInstanceId]?.[dataValueMapping['muac_num']] || '')}
                                                                    onChange={(e) => {
                                                                        // strip out anything that isn’t a digit
                                                                        const onlyDigits = e.target.value.replace(/\D/g, '');
                                                                        const classification = computeMuacClassification(
                                                                            onlyDigits,
                                                                            ben.beneficiaryStage
                                                                        );
                                                                        // Update both muac_num and muacClassification in memory
                                                                        handleEditMuacChange(
                                                                            ben.trackInstanceId,
                                                                            onlyDigits,
                                                                            classification
                                                                        );
                                                                        // setMuacClass(classification);
                                                                    }}
                                                                    onKeyDown={(e) => {
                                                                        // allow only digits, Backspace, Delete, arrows, Tab
                                                                        if (
                                                                            !/[0-9]/.test(e.key) &&
                                                                            e.key !== 'Backspace' &&
                                                                            e.key !== 'Delete' &&
                                                                            e.key !== 'ArrowLeft' &&
                                                                            e.key !== 'ArrowRight' &&
                                                                            e.key !== 'Tab' &&
                                                                            e.key !== 'Enter'
                                                                        ) {
                                                                            e.preventDefault();
                                                                        }

                                                                        if (e.key === 'Enter') {
                                                                            const training = col.training || selectedTrainings[0];
                                                                            sendDataValueUpdate(
                                                                                ben.trackInstanceId,
                                                                                dataValueMapping[col.accessor],
                                                                                // fetchedData.dataValues[dataValueMapping[col.accessor]],
                                                                                editInputValues[ben.trackInstanceId]?.[dataValueMapping['muac_num']],
                                                                                training
                                                                            );
                                                                            // Save Classification
                                                                            sendDataValueUpdate(
                                                                                ben.trackInstanceId,
                                                                                dataValueMapping['muacClassification'],
                                                                                editInputValues[ben.trackInstanceId]?.[dataValueMapping['muac_num']],
                                                                                training
                                                                            );

                                                                        }
                                                                    }}
                                                                    placeholder="Enter MUAC"
                                                                    style={{
                                                                        ...style,
                                                                        opacity: !(editInputValues[ben.trackInstanceId]?.dataValues?.['Present'] === true) ? 0.5 : 1,
                                                                        pointerEvents: !(editInputValues[ben.trackInstanceId]?.dataValues?.['Present'] === true) ? 'none' : 'auto'
                                                                    }}
                                                                    title="Press Enter to save the MUAC value"
                                                                />
                                                            );
                                                        } else if (col.accessor === 'oedema_checkBox') {
                                                            return (
                                                                <input
                                                                    type="checkbox"
                                                                    // checked={editInputValues[ben.trackInstanceId]?.dataValues?.[col.accessor] === true ||
                                                                    //     editInputValues[ben.trackInstanceId]?.dataValues?.[col.accessor] === 'true'
                                                                    // }
                                                                    checked={!!editInputValues[ben.trackInstanceId]?.[dataValueMapping[col.accessor]]}
                                                                    onChange={e => {
                                                                        handleEditInputChange(
                                                                            ben.trackInstanceId,
                                                                            dataValueMapping[col.accessor],
                                                                            e.target.checked
                                                                        );
                                                                    }}

                                                                    style={{
                                                                        // ...style,
                                                                        opacity: !(editInputValues[ben.trackInstanceId]?.dataValues?.['Present'] === true) ? 0.5 : 1,
                                                                        pointerEvents: !(editInputValues[ben.trackInstanceId]?.dataValues?.['Present'] === true) ? 'none' : 'auto'
                                                                    }}
                                                                />
                                                            );
                                                        } else {
                                                            // First check if present
                                                            const isPresent = editInputValues[ben.trackInstanceId]?.dataValues?.['Present'] === true ||
                                                                editInputValues[ben.trackInstanceId]?.dataValues?.['Present'] === 'true';

                                                            if (!isPresent) {
                                                                return '—'; // Show dash if not present
                                                            }

                                                            // Check if this indirect beneficiary has their own value
                                                            const ownValue = editInputValues[ben.trackInstanceId]?.dataValues?.[dataValueMapping[col.accessor]];

                                                            // If no own value, inherit from parent (but only for non-MUAC columns)
                                                            const valueToDisplay = ownValue !== undefined ? ownValue :
                                                                (!['Oedema', 'Muac', 'Muac Classification'].includes(dataValueMapping[col.accessor]))
                                                                    ? parentData.dataValues?.[dataValueMapping[col.accessor]]
                                                                    : undefined;

                                                            // Render appropriately
                                                            if (valueToDisplay === undefined) {
                                                                return '—';
                                                            }
                                                            if (typeof valueToDisplay === 'boolean') {
                                                                return renderCheckCell(valueToDisplay);
                                                            }
                                                            return valueToDisplay || '—';
                                                        }
                                                    }
                                                    return '—';
                                                })()

                                            )
                                        }
                                    </td>
                                );
                            })}

                        </tr>)

                })}
            </>
        )
    };

    const handleColumnToggle = (topic) => {
        setTopicsVis(prev => ({
            ...prev,
            [topic]: !prev[topic],  // Toggle visibility
        }));
    };

    const handleShowAllRecords = () => {
        setLockSelection(false);
        setSelectedRecordOnly(false); // Stop filtering to one record
        setSelectedBeneficiary(null); // Clear the selected beneficiary
        setEditableRows({});          // Ensure no rows are in edit mode
        setBeneficiarySearch('');     // Clear any search/highlight term
        // Optionally clear indirect beneficiaries if they should only show when one row is selected
        // setIndirectBeneficiaries([]);
    };

    const handleRecordClick = async (activity: OrgUnitDetails) => {
        // Lock selection to prevent interference
        setLockSelection(true);

        const trackInstId = activity.trackInstanceId;
        const isCurrentlySelected = selectedBeneficiary?.trackInstanceId === trackInstId;

        // Track filter logic
        if (activity.track === 'Fisher' || activity.track === 'Farmer') {
            setTrackFilter(activity.track);
            setNewRowData((prevData) => ({ ...prevData, track: activity.track }));
            setNewIndirectData((prevData) => ({ ...prevData, track: activity.track }));
        }

        if (!isCurrentlySelected) {
            setIsNewEntry(prev => ({ ...prev, [trackInstId]: true }));

            setEditInputValues(prev => ({
                ...prev,
                [trackInstId]: {} // Initialize as empty object for this row
            }));

            setSelectedBeneficiary(activity);
            setSelectedRecordOnly(true);
            setFilteredData([activity]);
            setEditableRows({ [trackInstId]: true });
            setBeneficiarySearch(activity.patientID);

            const indirect = activity.patientID
                ? props.orgUnitDetails.filter(b => b.directPatientID === activity.patientID)
                : [];
            setIndirectBeneficiaries(indirect);
        }
        // Removed deselect logic completely
    };

    return (
        <main className="space-y-4">
            {/* <Header
                onAdd={onAdd}
            // onDownloadCSV={() => handleDownloadCSV('')}
            /> */}

            <div className="" style={{ display: 'flex', alignItems: 'center', marginBottom: '10px' }}>
                {/* Training Filters */}
                <h5 style={{ padding: '10px' }}>Training</h5>
                <button
                    onClick={() => window.location.reload()}
                    className="border border-gray-300 rounded-md p-2"
                    style={{
                        borderRadius: '5px',
                        width: '160px',
                        height: '40px',
                        padding: '5px',
                        marginLeft: '5px'
                    }}
                // title="Refresh page"
                >
                    <span style={{ display: 'flex', alignItems: 'center', justifyContent: 'center' }}>New Beneficiary</span>
                </button>
            </div>


            {/* First div block - Search, New Beneficiary, Track and Program Stage filters */}
            <div className="flex space-x-4" style={{
                padding: '0px 10px 10px 10px',
                display: 'flex',
                alignItems: 'center',
                gap: '20px'
            }}>

                {/* Track Filter */}
                <select
                    value={trackFilter}
                    onChange={(e) => {
                        const selectedTrack = e.target.value;
                        setTrackFilter(e.target.value);
                        setNewRowData((prevData) => ({ ...prevData, track: selectedTrack })); // Set the selected track in newRowData
                        setNewIndirectData((prevData) => ({ ...prevData, track: selectedTrack })) // Set selected track in new Indirect ben Row
                        if (trainingFilter === 'Livelihood') {
                            // Force column update when track changes
                            setAdditionalColumns(getAdditionalColumns(trainingFilter));
                        }
                    }}
                    className="border border-gray-300 rounded-md p-2"
                    style={{
                        borderRadius: '5px',
                        width: '150px',        // Standard width
                        height: '40px',        // Standard height
                        padding: '15px 10px '    // Comfortable padding
                    }}
                >
                    <option value="" style={{ marginTop: '-2px' }}>Select Tracker</option>
                    <option value="Fisher">Fisher</option>
                    <option value="Farmer">Farmer</option>
                </select>

                {/* Search Beneficiary */}
                <input
                    type="text"
                    placeholder="Search Beneficiary"
                    value={beneficiarySearch}
                    // onChange={(e) => setBeneficiarySearch(e.target.value)}
                    onChange={(e) => {
                        if (!trackFilter) {
                            setMessage('Please select a tracker (Farmer or Fisher) before searching for beneficiary.');
                            setIsError(true);
                            return; // Stop if no track selected
                        }
                        handleBeneficiarySearch1(e);
                    }}
                    className="border border-gray-300 rounded-md"
                    style={{
                        borderRadius: '5px',
                        width: '200px',
                        height: '40px',
                        padding: '5px 10px'
                    }}
                />

                {/* Program Stage Radio Buttons */}
                <div style={{
                    display: 'flex',
                    alignItems: 'center',
                    gap: '25px'    // Increased gap between radio buttons
                }}>
                    <label style={{ display: 'flex', alignItems: 'center', gap: '5px' }}>
                        <input
                            type="radio"
                            value="Livelihood"
                            // checked={trainingFilter === 'Livelihood'}
                            checked={selectedTrainings.length === 1 && selectedTrainings[0] === 'Livelihood'}
                            onChange={(e) => {
                                handleFilterChange('Livelihood')

                            }}
                        />
                        Livelihood
                    </label>
                    <label style={{ display: 'flex', alignItems: 'center', gap: '5px' }}>
                        <input
                            type="checkbox"
                            value="Water Sanitation & Hygiene"
                            // checked={trainingFilter === 'Water Sanitation & Hygiene'}
                            checked={selectedTrainings.includes('Water Sanitation & Hygiene')}
                            onChange={() => handleFilterChange('Water Sanitation & Hygiene')}
                        />
                        Water Sanitation & Hygiene
                    </label>
                    <label style={{ display: 'flex', alignItems: 'center', gap: '5px' }}>
                        <input
                            type="checkbox"
                            value="Nutrition"
                            // checked={trainingFilter === 'Nutrition'}
                            checked={selectedTrainings.includes('Nutrition')}
                            onChange={() => handleFilterChange('Nutrition')}
                        />
                        Nutrition
                    </label>
                </div>

                {/* Column Selector */}

                {/* Topics Selector */}
                <div className="relative column-filter-dropdown" ref={dropdownRef} style={{ position: 'relative' }}>
                    <button
                        className="btn btn-secondary"
                        onClick={() => {
                            // REQUIREMENT 1: Check if track filter is selected
                            if (!trackFilter) {
                                setMessage('Please select a tracker (Farmer or Fisher) before viewing topics.');
                                setIsError(true);
                                return; // Stop if no track selected
                            }
                            setShowTopics(!showTopics)
                        }
                        }
                        style={{ zIndex: 1000 }}
                    >
                        Topics ▼
                    </button>
                    {showTopics && (
                        <div className="filter-menu absolute mt-1 p-2 bg-white border rounded shadow-lg z-10"
                            style={{ minWidth: '220px', zIndex: 999 }}>

                            {/* 1. Always show Shared columns (Date of Training) */}
                            {additionalColumns.some(col => col.training === 'shared') && (
                                <div>
                                    <div className="font-bold mt-2 mb-1 text-sm first:mt-0">
                                        <b>Shared</b>
                                    </div>
                                    {additionalColumns
                                        .filter(col => col.training === 'shared')
                                        .map(col => (
                                            <label key={col.accessor} className="flex items-start py-1 pl-2">
                                                <input
                                                    type="checkbox"
                                                    checked={topicsVis[col.accessor] ?? true}
                                                    onChange={() => handleColumnToggle(col.accessor)}
                                                />
                                                {col.Header}
                                            </label>
                                        ))}
                                </div>
                            )}

                            {/* 2. Always show MUAC Assessment section if any training is selected */}
                            {selectedTrainings.length > 0 && (
                                <div>
                                    <div className="font-bold mt-2 mb-1 text-sm">
                                        <b>Muac Assessment</b>
                                    </div>
                                    {additionalColumns
                                        .filter(col => col.training === 'Muac Assessment')
                                        .map(col => (
                                            <label
                                                key={col.accessor}
                                                className="flex items-start py-1 pl-2"
                                                style={{ marginRight: '10px' }}
                                            >
                                                <input
                                                    type="checkbox"
                                                    checked={topicsVis[col.accessor] ?? true}
                                                    onChange={() => handleColumnToggle(col.accessor)}
                                                />
                                                {col.Header}
                                            </label>
                                        ))}
                                </div>
                            )}

                            {/* 3. Show other training sections */}
                            {Array.from(new Set(additionalColumns
                                .filter(col => !['shared', 'Muac Assessment', 'Action'].includes(col.training))
                                .map(c => c.training)))
                                .filter(training => training)
                                .map(training => (
                                    <div key={training}>
                                        <div className="font-bold mt-2 mb-1 text-sm">
                                            <b>{training}</b>
                                        </div>
                                        {additionalColumns
                                            .filter(col => col.training === training)
                                            .map(col => (
                                                <label key={col.accessor} className="flex items-start py-1 pl-2">
                                                    <input
                                                        type="checkbox"
                                                        checked={topicsVis[col.accessor] ?? true}
                                                        onChange={() => handleColumnToggle(col.accessor)}
                                                    />
                                                    {col.Header}
                                                </label>
                                            ))}
                                    </div>
                                ))}

                            {/* 4. Action column at the bottom */}
                            <div className="mt-3 pt-2 border-t">
                                <div className="font-bold mb-1 text-sm">
                                    <b>Actions</b>
                                </div>
                                {additionalColumns
                                    .filter(col => col.training === 'Action')
                                    .map(col => (
                                        <label key={col.accessor} className="flex items-start py-1 pl-2">
                                            <input
                                                type="checkbox"
                                                checked={topicsVis[col.accessor] ?? true}
                                                onChange={() => handleColumnToggle(col.accessor)}
                                            />
                                            {col.Header}
                                        </label>
                                    ))}
                            </div>
                        </div>
                    )}
                </div>

                {/*  Revert to all table rows */}
                {selectedRecordOnly && (
                    <button
                        onClick={handleShowAllRecords}
                        className="border border-gray-300 rounded-md"
                        style={{
                            borderRadius: '5px',
                            height: '40px',
                            padding: '5px 10px',
                            backgroundColor: '#f8f9fa',
                            cursor: 'pointer',
                            marginLeft: '10px'
                        }}
                    >
                        Show All Records
                    </button>
                )}

            </div>

            {/* Second div block - Add Beneficiary */}
            {/* Message Display Area */}
            <div style={{ minHeight: '3em', padding: '0 10px', position: 'relative' }}> {/* Added div for messages */}
                {message && (
                    <div className={isError ? 'error-message' : 'success-message'}>
                        {/* {message} */}
                        {typeof message === 'string' ? message : message}
                    </div>
                )}
            </div>

            {/* Modal for Search Results */}
            {isModalVisible && (
                <Modal
                    // onClose={closeModal}

                    orgUnitId={props.orgUnitId}
                    trackInstanceId={''}
                    trainingFilter={trainingFilter}
                    LivelihoodForm={LivelihoodForm}
                    WaterSanitationForm={WaterSanitationForm}
                    NutritionForm={NutritionForm}

                >
                    <h2>Person Search Results</h2>
                    <table className="min-w-full border-collapse border border-gray-300">
                        <thead>
                            <tr>
                                <th className="border border-gray-300">Registering unit</th>
                                <th className="border border-gray-300">Registration date</th>
                                <th className="border border-gray-300">Inactive</th>
                                <th className="border border-gray-300">First Name and Middle Name</th>
                                <th className="border border-gray-300">Patient ID #</th>
                                <th className="border border-gray-300">Surname</th>
                                <th className="border border-gray-300">Age</th>
                                <th className="border border-gray-300">Date of Birth</th>
                                <th className="border border-gray-300">Sex</th>
                                <th className="border border-gray-300">Beneficiary Track</th>


                            </tr>
                        </thead>
                        <tbody>
                            {searchResults.map((row, index) => (
                                <tr key={index}
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        handleRecordClick(row)
                                    }}
                                >
                                    <td className="border border-gray-300">{row[4]}</td>
                                    <td className="border border-gray-300">{row[1]}</td>
                                    <td className="border border-gray-300">{"No"}</td>
                                    <td className="border border-gray-300">{row[8]}</td>
                                    <td className="border border-gray-300">{row[12]}</td>
                                    <td className="border border-gray-300">{row[13]}</td>
                                    <td className="border border-gray-300">{row[14]}</td>
                                    <td className="border border-gray-300">{row[15]}</td>
                                    <td className="border border-gray-300">{row[16]}</td>
                                    <td className="border border-gray-300">{row[18]}</td>

                                </tr>
                            ))}
                        </tbody>
                    </table>
                    {showFilterForm && selectedRecord && (
                        <div>
                            {/* Render the specific filter form based on the selected record */}

                            {trainingFilter === 'Livelihood' && (
                                <LivelihoodForm
                                    place={selectedRecord[4]}
                                    track={selectedRecord[18]}
                                    orgUnit={props.orgUnitId}
                                    trackInstance={selectedRecord[0]}
                                />
                            )}
                            {trainingFilter === 'Water Sanitation & Hygiene' && (
                                <WaterSanitationForm
                                    place={selectedRecord[4]}
                                    track={selectedRecord[18]}
                                    orgUnit={props.orgUnitId}
                                    trackInstance={selectedRecord[0]}
                                />
                            )}
                            {trainingFilter === 'Nutrition' && (
                                <NutritionForm
                                    place={selectedRecord[4]}
                                    track={selectedRecord[18]}
                                    orgUnit={props.orgUnitId}
                                    trackInstance={selectedRecord[0]}
                                />
                            )}
                        </div>
                    )}
                </Modal>
            )}

            {/* Beneficiaries Table */}
            {(!formVisible && (beneficiarySearch || trackFilter)) && (
                <>
                    <div className="table-responsive">
                        <table
                            key={`table-${resetTrigger}`}
                            className="table table-striped table-bordered table-hover table-dark-header">
                            <thead>
                                <tr>
                                    {columnsVis
                                        .filter(c => c.visible)
                                        .map(c => (
                                            <th key={c.accessor}>{c.Header}</th>
                                        ))
                                    }
                                    {/* then your numbered additional‑columns… */}
                                    {additionalColumns
                                        .filter(col => topicsVis[col.accessor])
                                        .map((col) => {
                                            let label = '';
                                            const fullIndex = additionalColumns.findIndex(c => c.accessor === col.accessor);

                                            if (col.accessor === 'reportDate') {
                                                label = 'Date of Training';
                                            } else if (col.accessor === 'addEditEvent') {
                                                label = `Action`;
                                            } else if (col.accessor === 'oedema_checkBox') {
                                                label = 'Oedema';
                                            } else if (col.accessor === 'muac_num') {
                                                label = 'Muac';
                                            } else {
                                                // Extract the number from the Header (e.g. "1. Fishing Methods" -> "1")
                                                const match = col.Header.match(/^\s*(\d+)\./);
                                                const number = match ? match[1] : '';
                                                // count how many visible non-date, non-action columns come before this one
                                                const trainingPrefix =
                                                    col.training === 'Nutrition' ? 'NUT' :
                                                        col.training === 'Water Sanitation & Hygiene' ? 'WSH' :
                                                            col.training === 'Livelihood' ? 'LIV' :
                                                                'Muac';


                                                label = trainingPrefix ? `${trainingPrefix}-${number}` : col.Header;
                                            }
                                            return (
                                                <th
                                                    key={col.accessor}
                                                    className={`${col.headerClassName} numeric-header`}
                                                    title={col.Header}
                                                >
                                                    {label}
                                                </th>
                                            );
                                        })}

                                </tr>
                            </thead>

                            <tbody>
                                {renderTableRows()}
                                {/* New row form as part of the table */}
                            </tbody>
                        </table>
                    </div>
                </>
            )}

            {/* Indirect Beneficiaries Table */}
            {selectedBeneficiary && (
                <div className="mt-8">
                    <div className="flex justify-between items-center mb-4">
                        <h5 style={{ padding: '10px' }} >Direct Patient ID: {selectedBeneficiary.patientID}</h5>
                        <button
                            onClick={(e) => {
                                e.stopPropagation();
                                handleIndirectBeneficiaryAdd();
                            }}
                            className="border border-gray-300 rounded-md"
                            style={{
                                borderRadius: '5px',
                                height: '40px',
                                padding: '5px 10px',
                                backgroundColor: '#f8f9fa',
                                cursor: 'pointer',
                                marginLeft: '10px'
                            }}
                        >
                            + Indirect Beneficiary
                        </button>
                        <div style={{
                            fontSize: '0.8rem',
                            color: '#666',
                            maxWidth: '300px',
                            marginTop: '5px',
                            marginLeft: '10px',
                            padding: '5px',
                            backgroundColor: '#f8f8f8',
                            borderRadius: '4px'
                        }}>
                            <strong>Note:</strong> Records with blinking red border need attendance marked.
                        </div>
                    </div>

                    <div className="table-responsive">
                        <table className="table table-striped table-bordered table-hover table-dark-header">
                            <thead>
                                <tr>
                                    {/* 3 New Present / Absent header */}
                                    <th>Present</th>

                                    {/* 1 Original columns – exactly the same visibile set you chose in part 1 */}
                                    {columnsVis
                                        .filter(c => c.visible)
                                        .map(c => (
                                            <th key={c.accessor}>{c.Header}</th>
                                        ))
                                    }
                                    {/* 2 Numbered additional columns */}

                                    {additionalColumns
                                        .filter(col => topicsVis[col.accessor] && col.accessor !== 'addEditEvent')
                                        .map((col) => {

                                            let label = '';
                                            if (col.accessor === 'reportDate') {
                                                label = 'Date of Training';
                                            } else if (col.accessor === 'oedema_checkBox') {
                                                label = 'Oedema';
                                            } else if (col.accessor === 'muac_num') {
                                                label = 'Muac';
                                            } else {

                                                // Extract the number from the Header (e.g. "1. Fishing Methods" -> "1")
                                                const match = col.Header.match(/^\s*(\d+)\./);
                                                const number = match ? match[1] : '';
                                                // Get the training prefix
                                                const trainingPrefix =
                                                    col.training === 'Nutrition' ? 'NUT' :
                                                        col.training === 'Water Sanitation & Hygiene' ? 'WSH' :
                                                            col.training === 'Livelihood' ? 'LIV' : '';


                                                label = trainingPrefix ? `${trainingPrefix}-${number}` : col.Header;
                                            }

                                            return (
                                                <th
                                                    key={col.accessor}
                                                    className={`${col.headerClassName} numeric-header`}
                                                    title={col.Header}
                                                >
                                                    {label}
                                                </th>
                                            );
                                        })
                                    }
                                </tr>
                            </thead>

                            <tbody>
                                {indirectBeneficiaries.length === 0 ? (

                                    <tr>
                                        <td colSpan={14} className="text-center">
                                            No indirect beneficiaries found for this record
                                        </td>
                                    </tr>
                                ) : (
                                    renderIndirectRows()
                                )}

                                {/* {renderIndirectRows()} */}

                                {/* Editable row for new indirect beneficiary */}
                                {isAddingIndirect && (
                                    <tr>
                                        <td> {/* This is the 'Present' column */}
                                            <input
                                                type="checkbox"
                                                checked={isNewIndirectPresent}
                                                onChange={(e) => setIsNewIndirectPresent(e.target.checked)}
                                                disabled
                                                className="disabled-checkbox"
                                                title="Save beneficiary first before marking attendance"
                                            // Optionally disable if no training is selected? Or allow marking present even without training?
                                            // For now, let's allow checking even without training selected, though saving won't create training events.
                                            />
                                        </td>
                                        <td className="min-w-[120px]">
                                            <input
                                                type="date"
                                                value={newIndirectData.recordDate}
                                                onChange={(e) => setNewIndirectData({ ...newIndirectData, recordDate: e.target.value })}
                                                className="w-full p-2 mb-2"
                                            />
                                        </td>
                                        <td className="min-w-[120px]">
                                            <select
                                                className="table-select w-full p-2 mb-2"
                                                name="beneficiaryStage"
                                                value={newIndirectData.beneficiaryStage}
                                                // onChange={(e) => setNewRowData({ ...newRowData, beneficiaryStage: e.target.value })}

                                                onChange={(e) => {
                                                    const newStage = e.target.value;
                                                    const classification = computeMuacClassification(newIndirectData.initialMuac, newStage);

                                                    setNewIndirectData((prev) => ({
                                                        ...prev,
                                                        beneficiaryStage: newStage,
                                                        muacClassification: classification,
                                                    }));
                                                }}
                                            >
                                                <option value="">Select Beneficiary Stage</option>
                                                <option value="Adult">Adult</option>
                                                <option value="Child">Child</option>
                                            </select>
                                        </td>
                                        <td className="min-w-[120px]">
                                            <input
                                                className="table-select w-full p-2 mb-2"
                                                name="beneficiaryType"
                                                value='Indirect Beneficiary'
                                                readOnly
                                                disabled={!newIndirectData.beneficiaryStage}
                                            />
                                        </td>

                                        <td className="min-w-[120px]">
                                            <input
                                                type="text"
                                                value={newIndirectData.first_middleName}
                                                onChange={(e) => setNewIndirectData({ ...newIndirectData, first_middleName: e.target.value })}
                                                className="w-full p-2 mb-2"
                                                placeholder="First Name and Middle Name"
                                                disabled={!newIndirectData.beneficiaryStage}
                                            />
                                        </td>
                                        <td className="min-w-[120px]">
                                            <input
                                                type="text"
                                                className="table-input w-full p-2 mb-2"
                                                value={newIndirectData.surname}
                                                onChange={(e) => setNewIndirectData({ ...newIndirectData, surname: e.target.value })}
                                                placeholder="Surname"
                                                disabled={!newIndirectData.beneficiaryStage}
                                            />
                                        </td>
                                        <td className="min-w-[120px]" style={{ minWidth: '120px' }}>
                                            <select
                                                className="table-select w-full p-2 mb-2"
                                                value={newIndirectData.sex}
                                                onChange={(e) => setNewIndirectData({ ...newIndirectData, sex: e.target.value })}
                                                disabled={!newIndirectData.beneficiaryStage}
                                            >
                                                <option value="">Select Gender</option>
                                                <option value="Male">Male</option>
                                                <option value="Female">Female</option>
                                            </select>
                                        </td>
                                        <td className="min-w-[120px]" style={{ minWidth: '120px' }}>
                                            <input
                                                type="text"
                                                inputMode="numeric"
                                                pattern="[0-9]*"
                                                name="age"
                                                value={newIndirectData.age}
                                                // onChange={handleNewRowInputChange}
                                                onChange={e => {
                                                    // strip out anything that isn’t a digit
                                                    const onlyDigits = e.target.value.replace(/\D/g, '')
                                                    setNewIndirectData({ ...newIndirectData, age: onlyDigits })
                                                }}
                                                onKeyDown={e => {
                                                    // allow only digits, Backspace, Delete, arrows, Tab
                                                    if (
                                                        !/[0-9]/.test(e.key) &&
                                                        e.key !== 'Backspace' &&
                                                        e.key !== 'Delete' &&
                                                        e.key !== 'ArrowLeft' &&
                                                        e.key !== 'ArrowRight' &&
                                                        e.key !== 'Tab'
                                                    ) {
                                                        e.preventDefault()
                                                    }
                                                }}
                                                style={{ width: '100%' /* keep full‐width even if table cols shrink */ }}
                                                placeholder="Age"
                                                className="w-full p-2 mb-2"
                                                disabled={!newIndirectData.beneficiaryStage}
                                            />
                                        </td>
                                        <td className="min-w-[120px]">
                                            <input
                                                type="date"
                                                name="dob"
                                                value={newIndirectData.dob}
                                                // onChange={handleNewRowInputChange}
                                                onChange={(e) => setNewIndirectData({ ...newIndirectData, dob: e.target.value })}
                                                className="w-full p-2 mb-2"
                                                disabled={!newIndirectData.beneficiaryStage}
                                            />
                                        </td>

                                        <td className="min-w-[120px]">
                                            <input
                                                type="text"
                                                className="table-input w-full p-2 mb-2"
                                                name="track"
                                                value={newRowData.track}
                                                // onChange={handleNewRowInputChange}
                                                onChange={(e) => setNewIndirectData({ ...newIndirectData, track: e.target.value })}
                                                readOnly
                                                placeholder="Beneficiary Track"
                                                disabled={!newIndirectData.beneficiaryStage}
                                            />
                                        </td>
                                        <td>
                                            <button
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    handleSaveIndirect()
                                                }
                                                }
                                                className="submit-button"
                                                disabled={!newIndirectData.beneficiaryStage}
                                            >
                                                Save
                                            </button>
                                            <button
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    setIsAddingIndirect(false)
                                                }}
                                                style={{ marginLeft: '5px' }}
                                                className="cancel-button"

                                            >
                                                Cancel
                                            </button>
                                        </td>
                                    </tr>
                                )}
                            </tbody>
                        </table>
                    </div>
                </div>
            )}

            {!formVisible && <TablePagination table={table} />}
        </main>

    );

}
